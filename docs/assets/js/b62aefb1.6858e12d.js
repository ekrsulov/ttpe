"use strict";(self.webpackChunkttpe_docs=self.webpackChunkttpe_docs||[]).push([[346],{8453:(e,n,t)=>{t.d(n,{R:()=>a,x:()=>l});var s=t(6540);const r={},i=s.createContext(r);function a(e){const n=s.useContext(i);return s.useMemo(function(){return"function"==typeof e?e(n):{...n,...e}},[n,e])}function l(e){let n;return n=e.disableParentContext?"function"==typeof e.components?e.components(r):e.components||r:a(e.components),s.createElement(i.Provider,{value:n},e.children)}},9634:(e,n,t)=>{t.r(n),t.d(n,{assets:()=>o,contentTitle:()=>l,default:()=>h,frontMatter:()=>a,metadata:()=>s,toc:()=>c});const s=JSON.parse('{"id":"features/transforms","title":"Transform System","description":"The Transform System provides intuitive visual handles for resizing, rotating, and transforming selected elements on the canvas. It supports both proportional and free-form scaling, rotation with angle snapping, and real-time visual feedback during transformations.","source":"@site/docs/features/transforms.md","sourceDirName":"features","slug":"/features/transforms","permalink":"/ttpe/docs/docs/features/transforms","draft":false,"unlisted":false,"editUrl":"https://github.com/ekrsulov/ttpe/tree/main/doc/docs/features/transforms.md","tags":[],"version":"current","lastUpdatedBy":"Ernesto Krsulovic","lastUpdatedAt":1762144584000,"frontMatter":{"id":"transforms","title":"Transform System","sidebar_label":"Transforms"},"sidebar":"docs","previous":{"title":"Selection","permalink":"/ttpe/docs/docs/features/selection"},"next":{"title":"Ordering","permalink":"/ttpe/docs/docs/features/ordering"}}');var r=t(4848),i=t(8453);const a={id:"transforms",title:"Transform System",sidebar_label:"Transforms"},l="Transform System",o={},c=[{value:"Overview",id:"overview",level:2},{value:"Transform Operations",id:"transform-operations",level:2},{value:"Resize (Scale)",id:"resize-scale",level:3},{value:"Rotate",id:"rotate",level:3},{value:"Move (Translate)",id:"move-translate",level:3},{value:"Transform Flow Diagram",id:"transform-flow-diagram",level:2},{value:"Transform Handle System",id:"transform-handle-system",level:2},{value:"Transform Mathematics",id:"transform-mathematics",level:2},{value:"Scale Calculation",id:"scale-calculation",level:3},{value:"Rotation Calculation",id:"rotation-calculation",level:3},{value:"Transform Matrix Application",id:"transform-matrix-application",level:3},{value:"Visual Feedback",id:"visual-feedback",level:2},{value:"Dimension Display",id:"dimension-display",level:3},{value:"Angle Display",id:"angle-display",level:3},{value:"Handle Highlighting",id:"handle-highlighting",level:3},{value:"Keyboard Modifiers",id:"keyboard-modifiers",level:2},{value:"Shift Key",id:"shift-key",level:3},{value:"Alt/Option Key",id:"altoption-key",level:3},{value:"API Reference",id:"api-reference",level:2},{value:"Store Methods",id:"store-methods",level:3},{value:"Hook Usage",id:"hook-usage",level:3},{value:"Transform Controller",id:"transform-controller",level:3},{value:"Advanced Features",id:"advanced-features",level:2},{value:"Subpath Transformation",id:"subpath-transformation",level:3},{value:"Multi-Element Transformation",id:"multi-element-transformation",level:3},{value:"Stroke Width Scaling",id:"stroke-width-scaling",level:3},{value:"Best Practices",id:"best-practices",level:2},{value:"For Users",id:"for-users",level:3},{value:"For Plugin Developers",id:"for-plugin-developers",level:3},{value:"Common Use Cases",id:"common-use-cases",level:2},{value:"Resize to Specific Dimensions",id:"resize-to-specific-dimensions",level:3},{value:"Rotate to Specific Angle",id:"rotate-to-specific-angle",level:3},{value:"Flip Horizontally/Vertically",id:"flip-horizontallyvertically",level:3},{value:"Troubleshooting",id:"troubleshooting",level:2},{value:"Transform not visible",id:"transform-not-visible",level:3},{value:"Proportional scaling not working",id:"proportional-scaling-not-working",level:3},{value:"Rotation jumps unexpectedly",id:"rotation-jumps-unexpectedly",level:3},{value:"Stroke width becomes too thick/thin",id:"stroke-width-becomes-too-thickthin",level:3},{value:"Related Documentation",id:"related-documentation",level:2}];function d(e){const n={a:"a",code:"code",h1:"h1",h2:"h2",h3:"h3",header:"header",hr:"hr",li:"li",mermaid:"mermaid",ol:"ol",p:"p",pre:"pre",strong:"strong",ul:"ul",...(0,i.R)(),...e.components};return(0,r.jsxs)(r.Fragment,{children:[(0,r.jsx)(n.header,{children:(0,r.jsx)(n.h1,{id:"transform-system",children:"Transform System"})}),"\n",(0,r.jsx)(n.p,{children:"The Transform System provides intuitive visual handles for resizing, rotating, and transforming selected elements on the canvas. It supports both proportional and free-form scaling, rotation with angle snapping, and real-time visual feedback during transformations."}),"\n",(0,r.jsx)(n.h2,{id:"overview",children:"Overview"}),"\n",(0,r.jsxs)(n.p,{children:["Transformations in TTPE are ",(0,r.jsx)(n.strong,{children:"non-destructive"})," and ",(0,r.jsx)(n.strong,{children:"reversible"}),". When you transform elements, the system calculates scale, rotation, and translation matrices that are applied to the underlying path data. All transformations respect the undo/redo history and can be combined with other operations."]}),"\n",(0,r.jsx)(n.p,{children:"The system provides:"}),"\n",(0,r.jsxs)(n.ul,{children:["\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.strong,{children:"8-handle bounding box"}),": Corner and edge handles for precise control"]}),"\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.strong,{children:"Rotation handle"}),": Circular handle above the bounding box"]}),"\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.strong,{children:"Proportional scaling"}),": Hold Shift to maintain aspect ratio"]}),"\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.strong,{children:"Center scaling"}),": Hold Alt/Option to scale from center"]}),"\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.strong,{children:"Visual feedback"}),": Real-time dimension and angle display"]}),"\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.strong,{children:"Snap to angles"}),": 15\xb0 increments when holding Shift during rotation"]}),"\n"]}),"\n",(0,r.jsx)(n.hr,{}),"\n",(0,r.jsx)(n.h2,{id:"transform-operations",children:"Transform Operations"}),"\n",(0,r.jsx)(n.h3,{id:"resize-scale",children:"Resize (Scale)"}),"\n",(0,r.jsx)(n.p,{children:"Drag any of the 8 handles on the bounding box to resize elements."}),"\n",(0,r.jsx)(n.p,{children:(0,r.jsx)(n.strong,{children:"Corner Handles (4):"})}),"\n",(0,r.jsxs)(n.ul,{children:["\n",(0,r.jsx)(n.li,{children:"Drag to scale both width and height"}),"\n",(0,r.jsxs)(n.li,{children:["Hold ",(0,r.jsx)(n.strong,{children:"Shift"})," for proportional scaling (maintains aspect ratio)"]}),"\n",(0,r.jsxs)(n.li,{children:["Hold ",(0,r.jsx)(n.strong,{children:"Alt/Option"})," to scale from center point"]}),"\n",(0,r.jsx)(n.li,{children:"Visual feedback shows current dimensions"}),"\n"]}),"\n",(0,r.jsx)(n.p,{children:(0,r.jsx)(n.strong,{children:"Edge Handles (4):"})}),"\n",(0,r.jsxs)(n.ul,{children:["\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.strong,{children:"Top/Bottom"}),": Scale height only (width locked)"]}),"\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.strong,{children:"Left/Right"}),": Scale width only (height locked)"]}),"\n",(0,r.jsx)(n.li,{children:"No proportional constraint (independent axis scaling)"}),"\n"]}),"\n",(0,r.jsx)(n.p,{children:(0,r.jsx)(n.strong,{children:"Scale Limits:"})}),"\n",(0,r.jsxs)(n.ul,{children:["\n",(0,r.jsx)(n.li,{children:"Minimum scale: 0.05\xd7 (5% of original size)"}),"\n",(0,r.jsx)(n.li,{children:"Maximum scale: 10\xd7 (1000% of original size)"}),"\n",(0,r.jsx)(n.li,{children:"Prevents extreme or invalid transformations"}),"\n"]}),"\n",(0,r.jsx)(n.h3,{id:"rotate",children:"Rotate"}),"\n",(0,r.jsx)(n.p,{children:"Drag the circular rotation handle above the bounding box to rotate elements."}),"\n",(0,r.jsx)(n.p,{children:(0,r.jsx)(n.strong,{children:"Behavior:"})}),"\n",(0,r.jsxs)(n.ul,{children:["\n",(0,r.jsx)(n.li,{children:"Rotates around the center point of the bounding box"}),"\n",(0,r.jsxs)(n.li,{children:["Hold ",(0,r.jsx)(n.strong,{children:"Shift"})," to snap to 15\xb0 increments (0\xb0, 15\xb0, 30\xb0, 45\xb0, etc.)"]}),"\n",(0,r.jsx)(n.li,{children:"Visual angle indicator shows current rotation"}),"\n",(0,r.jsx)(n.li,{children:"Full 360\xb0 rotation support (no limits)"}),"\n"]}),"\n",(0,r.jsx)(n.p,{children:(0,r.jsx)(n.strong,{children:"Angle Display:"})}),"\n",(0,r.jsxs)(n.ul,{children:["\n",(0,r.jsx)(n.li,{children:"Real-time tooltip shows angle in degrees"}),"\n",(0,r.jsx)(n.li,{children:"Positive values: Clockwise rotation"}),"\n",(0,r.jsx)(n.li,{children:"Negative values: Counter-clockwise rotation"}),"\n",(0,r.jsx)(n.li,{children:"Wraps at \xb1180\xb0"}),"\n"]}),"\n",(0,r.jsx)(n.h3,{id:"move-translate",children:"Move (Translate)"}),"\n",(0,r.jsx)(n.p,{children:"Click and drag anywhere inside the bounding box (not on handles) to move elements."}),"\n",(0,r.jsx)(n.p,{children:(0,r.jsx)(n.strong,{children:"Behavior:"})}),"\n",(0,r.jsxs)(n.ul,{children:["\n",(0,r.jsx)(n.li,{children:"Maintains relative positions of all selected elements"}),"\n",(0,r.jsx)(n.li,{children:"Works with single or multi-selection"}),"\n",(0,r.jsx)(n.li,{children:"Respects grid snapping when enabled"}),"\n",(0,r.jsx)(n.li,{children:"Real-time position feedback"}),"\n"]}),"\n",(0,r.jsx)(n.hr,{}),"\n",(0,r.jsx)(n.h2,{id:"transform-flow-diagram",children:"Transform Flow Diagram"}),"\n",(0,r.jsx)(n.mermaid,{value:"flowchart TD\n    Start[User Activates Transform Mode] --\x3e Calculate[Calculate Bounding Box]\n    Calculate --\x3e Draw[Draw Handles & Box]\n    \n    Draw --\x3e WaitInput{User Input?}\n    \n    WaitInput --\x3e|Corner Handle| CheckMod{Modifier Keys?}\n    WaitInput --\x3e|Edge Handle| EdgeScale[Scale Single Axis]\n    WaitInput --\x3e|Rotation Handle| Rotate[Rotate Elements]\n    WaitInput --\x3e|Inside Box| Move[Translate Elements]\n    \n    CheckMod --\x3e|Shift| PropScale[Proportional Scale]\n    CheckMod --\x3e|Alt| CenterScale[Scale from Center]\n    CheckMod --\x3e|None| FreeScale[Free Scale Both Axes]\n    \n    PropScale --\x3e ApplyScale[Apply Scale Transform]\n    CenterScale --\x3e ApplyScale\n    FreeScale --\x3e ApplyScale\n    EdgeScale --\x3e ApplyScale\n    \n    Rotate --\x3e CheckSnap{Shift Pressed?}\n    CheckSnap --\x3e|Yes| SnapAngle[Snap to 15\xb0 Increments]\n    CheckSnap --\x3e|No| FreeRotate[Free Rotation]\n    \n    SnapAngle --\x3e ApplyRotate[Apply Rotation Transform]\n    FreeRotate --\x3e ApplyRotate\n    \n    Move --\x3e ApplyTranslate[Apply Translation]\n    \n    ApplyScale --\x3e UpdateMath[Update Transform Matrix]\n    ApplyRotate --\x3e UpdateMath\n    ApplyTranslate --\x3e UpdateMath\n    \n    UpdateMath --\x3e UpdatePath[Transform Path Commands]\n    UpdatePath --\x3e StrokeWidth[Calculate Scaled Stroke Width]\n    StrokeWidth --\x3e UpdateStore[Update Element in Store]\n    UpdateStore --\x3e Render[Re-render Canvas]\n    \n    Render --\x3e Feedback[Show Visual Feedback]\n    Feedback --\x3e WaitInput\n    \n    WaitInput --\x3e|Release Pointer| Commit[Commit Transform]\n    Commit --\x3e Undo[Add to Undo Stack]\n    Undo --\x3e End[Transform Complete]\n    \n    style PropScale fill:#e1f5ff\n    style SnapAngle fill:#fff4e1\n    style UpdateStore fill:#e1ffe1\n    style Commit fill:#ffe1e1"}),"\n",(0,r.jsx)(n.hr,{}),"\n",(0,r.jsx)(n.h2,{id:"transform-handle-system",children:"Transform Handle System"}),"\n",(0,r.jsx)(n.mermaid,{value:'graph TB\n    subgraph "Bounding Box Handles"\n        BB[Transform Bounding Box]\n        BB --\x3e TL[corner-tl: Top-Left]\n        BB --\x3e TR[corner-tr: Top-Right]\n        BB --\x3e BL[corner-bl: Bottom-Left]\n        BB --\x3e BR[corner-br: Bottom-Right]\n        BB --\x3e MT[midpoint-t: Top Edge]\n        BB --\x3e MB[midpoint-b: Bottom Edge]\n        BB --\x3e ML[midpoint-l: Left Edge]\n        BB --\x3e MR[midpoint-r: Right Edge]\n        BB --\x3e ROT[rotate-handle: Rotation]\n    end\n    \n    subgraph "Handle Behaviors"\n        TL --\x3e DIAG1[Diagonal Scale from BR]\n        TR --\x3e DIAG2[Diagonal Scale from BL]\n        BL --\x3e DIAG3[Diagonal Scale from TR]\n        BR --\x3e DIAG4[Diagonal Scale from TL]\n        \n        MT --\x3e VSCALE1[Vertical Scale from Bottom]\n        MB --\x3e VSCALE2[Vertical Scale from Top]\n        ML --\x3e HSCALE1[Horizontal Scale from Right]\n        MR --\x3e HSCALE2[Horizontal Scale from Left]\n        \n        ROT --\x3e ROTATE[Rotate Around Center]\n    end\n    \n    subgraph "Transform State"\n        TS[Transform State]\n        TS --\x3e AH[activeHandle: string or null]\n        TS --\x3e IB[initialBounds: Rect]\n        TS --\x3e CB[currentBounds: Rect]\n        TS --\x3e IT[initialTransform: Matrix]\n        TS --\x3e MK[modifierKeys: Shift Alt]\n    end\n    \n    DIAG1 --\x3e TS\n    VSCALE1 --\x3e TS\n    HSCALE1 --\x3e TS\n    ROTATE --\x3e TS\n    \n    style BB fill:#e1f5ff\n    style TS fill:#ffe1e1\n    style ROT fill:#fff4e1'}),"\n",(0,r.jsx)(n.hr,{}),"\n",(0,r.jsx)(n.h2,{id:"transform-mathematics",children:"Transform Mathematics"}),"\n",(0,r.jsx)(n.h3,{id:"scale-calculation",children:"Scale Calculation"}),"\n",(0,r.jsx)(n.p,{children:"When a handle is dragged, the system calculates scale factors:"}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-typescript",children:"// Corner handle scale (proportional with Shift)\nconst deltaX = currentPoint.x - dragStart.x;\nconst deltaY = currentPoint.y - dragStart.y;\n\nconst rawScaleX = (bounds.width + deltaX * signX) / bounds.width;\nconst rawScaleY = (bounds.height + deltaY * signY) / bounds.height;\n\nif (isShiftPressed) {\n  // Proportional: use minimum scale for both axes\n  const scale = Math.min(Math.abs(rawScaleX), Math.abs(rawScaleY));\n  scaleX = rawScaleX < 0 ? -scale : scale;\n  scaleY = rawScaleY < 0 ? -scale : scale;\n} else {\n  scaleX = rawScaleX;\n  scaleY = rawScaleY;\n}\n\n// Apply scale limits\nscaleX = clamp(scaleX, -10, 10);\nscaleY = clamp(scaleY, -10, 10);\n"})}),"\n",(0,r.jsx)(n.h3,{id:"rotation-calculation",children:"Rotation Calculation"}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-typescript",children:"// Calculate angle from center to current point\nconst centerX = bounds.x + bounds.width / 2;\nconst centerY = bounds.y + bounds.height / 2;\n\nconst angle = Math.atan2(\n  currentPoint.y - centerY,\n  currentPoint.x - centerX\n) * (180 / Math.PI);\n\nif (isShiftPressed) {\n  // Snap to 15\xb0 increments\n  return Math.round(angle / 15) * 15;\n}\n\nreturn angle;\n"})}),"\n",(0,r.jsx)(n.h3,{id:"transform-matrix-application",children:"Transform Matrix Application"}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-typescript",children:"// Apply transformation to path commands\nconst transformedCommands = transformCommands(subPath, {\n  scaleX,\n  scaleY,\n  originX,    // Transform origin point\n  originY,\n  rotation,   // In degrees\n  rotationCenterX,\n  rotationCenterY\n});\n\n// Scale stroke width proportionally\nconst scaledStrokeWidth = calculateScaledStrokeWidth(\n  originalStrokeWidth,\n  scaleX,\n  scaleY\n);\n"})}),"\n",(0,r.jsx)(n.hr,{}),"\n",(0,r.jsx)(n.h2,{id:"visual-feedback",children:"Visual Feedback"}),"\n",(0,r.jsx)(n.h3,{id:"dimension-display",children:"Dimension Display"}),"\n",(0,r.jsx)(n.p,{children:"During resize operations, a tooltip shows:"}),"\n",(0,r.jsxs)(n.ul,{children:["\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.strong,{children:"Current dimensions"}),': "Width \xd7 Height" in canvas units']}),"\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.strong,{children:"Delta values"}),': "+X, +Y" showing change from original']}),"\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.strong,{children:"Scale percentages"}),': "150% \xd7 200%" relative to original size']}),"\n"]}),"\n",(0,r.jsx)(n.h3,{id:"angle-display",children:"Angle Display"}),"\n",(0,r.jsx)(n.p,{children:"During rotation, a tooltip shows:"}),"\n",(0,r.jsxs)(n.ul,{children:["\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.strong,{children:"Current angle"}),': "45\xb0" or "Rotation: 45\xb0"']}),"\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.strong,{children:"Snap indicator"}),": Highlights when snapped to 15\xb0 increment"]}),"\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.strong,{children:"Direction"}),": Visual arc showing rotation direction"]}),"\n"]}),"\n",(0,r.jsx)(n.h3,{id:"handle-highlighting",children:"Handle Highlighting"}),"\n",(0,r.jsxs)(n.ul,{children:["\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.strong,{children:"Hover state"}),": Handle grows slightly and changes color"]}),"\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.strong,{children:"Active state"}),": Handle is highlighted while dragging"]}),"\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.strong,{children:"Cursor feedback"}),": Cursor changes based on handle type","\n",(0,r.jsxs)(n.ul,{children:["\n",(0,r.jsx)(n.li,{children:"Diagonal arrows for corner handles"}),"\n",(0,r.jsx)(n.li,{children:"Vertical/horizontal arrows for edge handles"}),"\n",(0,r.jsx)(n.li,{children:"Circular arrow for rotation handle"}),"\n"]}),"\n"]}),"\n"]}),"\n",(0,r.jsx)(n.hr,{}),"\n",(0,r.jsx)(n.h2,{id:"keyboard-modifiers",children:"Keyboard Modifiers"}),"\n",(0,r.jsx)(n.h3,{id:"shift-key",children:"Shift Key"}),"\n",(0,r.jsx)(n.p,{children:(0,r.jsx)(n.strong,{children:"During Resize:"})}),"\n",(0,r.jsxs)(n.ul,{children:["\n",(0,r.jsx)(n.li,{children:"Maintains aspect ratio (proportional scaling)"}),"\n",(0,r.jsx)(n.li,{children:"Applies to corner handles only (edge handles unaffected)"}),"\n",(0,r.jsx)(n.li,{children:'Visual indicator shows "Shift" in feedback tooltip'}),"\n"]}),"\n",(0,r.jsx)(n.p,{children:(0,r.jsx)(n.strong,{children:"During Rotation:"})}),"\n",(0,r.jsxs)(n.ul,{children:["\n",(0,r.jsx)(n.li,{children:"Snaps angle to 15\xb0 increments"}),"\n",(0,r.jsx)(n.li,{children:"Helps achieve precise angles (0\xb0, 45\xb0, 90\xb0, etc.)"}),"\n",(0,r.jsx)(n.li,{children:"Visual indicator shows angle snap"}),"\n"]}),"\n",(0,r.jsx)(n.h3,{id:"altoption-key",children:"Alt/Option Key"}),"\n",(0,r.jsx)(n.p,{children:(0,r.jsx)(n.strong,{children:"During Resize:"})}),"\n",(0,r.jsxs)(n.ul,{children:["\n",(0,r.jsx)(n.li,{children:"Scales from center point instead of opposite corner"}),"\n",(0,r.jsx)(n.li,{children:"Works with both corner and edge handles"}),"\n",(0,r.jsx)(n.li,{children:"Useful for symmetrical scaling"}),"\n"]}),"\n",(0,r.jsx)(n.hr,{}),"\n",(0,r.jsx)(n.h2,{id:"api-reference",children:"API Reference"}),"\n",(0,r.jsx)(n.h3,{id:"store-methods",children:"Store Methods"}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-typescript",children:"// Get store instance\nconst state = useCanvasStore.getState();\n\n// Apply resize transformation\nstate.applyResizeTransform?.(width: number, height: number): void\n\n// Apply rotation transformation\nstate.applyRotationTransform?.(degrees: number): void\n\n// Get transformation bounds\nstate.getTransformationBounds?.(): Rect | null\n\n// Update transformation state\nstate.updateTransformationState?.(state: Partial<TransformState>): void\n\n// Check if working with subpaths\nstate.isWorkingWithSubpaths?.(): boolean\n"})}),"\n",(0,r.jsx)(n.h3,{id:"hook-usage",children:"Hook Usage"}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-typescript",children:"import { useCanvasStore } from '../store/canvasStore';\n\n// Subscribe to transformation state\nconst transformation = useCanvasStore(state => state.transformation);\nconst isTransforming = transformation.isTransforming;\nconst activeHandle = transformation.activeHandler;\n\n// Get selected elements for transformation\nconst selectedIds = useCanvasStore(state => state.selectedIds);\nconst elements = useCanvasStore(state => state.elements);\nconst selectedElements = elements.filter(el => \n  selectedIds.includes(el.id)\n);\n"})}),"\n",(0,r.jsx)(n.h3,{id:"transform-controller",children:"Transform Controller"}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-typescript",children:"import { TransformController } from '../canvas/interactions/TransformController';\n\nconst controller = new TransformController();\n\n// Calculate transform update\nconst result = controller.calculateTransformUpdate(\n  currentPoint,\n  transformState,\n  elements,\n  isShiftPressed\n);\n\n// result.updatedElement: Transformed element\n// result.feedback: Visual feedback data (dimensions, angle, etc.)\n"})}),"\n",(0,r.jsx)(n.hr,{}),"\n",(0,r.jsx)(n.h2,{id:"advanced-features",children:"Advanced Features"}),"\n",(0,r.jsx)(n.h3,{id:"subpath-transformation",children:"Subpath Transformation"}),"\n",(0,r.jsx)(n.p,{children:"The system can transform individual subpaths within a multi-path element:"}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-typescript",children:"// Check if working with subpaths\nconst isSubpathMode = state.isWorkingWithSubpaths?.();\n\n// Transform only selected subpath\nif (isSubpathMode && selectedSubpathIndex !== null) {\n  // Transform just this subpath\n  transformSubpath(elementId, subpathIndex, transformMatrix);\n}\n"})}),"\n",(0,r.jsx)(n.h3,{id:"multi-element-transformation",children:"Multi-Element Transformation"}),"\n",(0,r.jsx)(n.p,{children:"Transform multiple selected elements as a group:"}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-typescript",children:"// All selected elements transform together\n// Maintains relative positions and proportions\n// Bounding box encompasses all elements\nconst selectionBounds = accumulateBounds(selectedElements);\n"})}),"\n",(0,r.jsx)(n.h3,{id:"stroke-width-scaling",children:"Stroke Width Scaling"}),"\n",(0,r.jsx)(n.p,{children:"Stroke width scales proportionally with the element:"}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-typescript",children:"// Calculate new stroke width\nconst scaledStroke = calculateScaledStrokeWidth(\n  originalStroke,\n  scaleX,\n  scaleY\n);\n\n// Use average of X and Y scales\nconst avgScale = (Math.abs(scaleX) + Math.abs(scaleY)) / 2;\nconst newStroke = originalStroke * avgScale;\n"})}),"\n",(0,r.jsx)(n.hr,{}),"\n",(0,r.jsx)(n.h2,{id:"best-practices",children:"Best Practices"}),"\n",(0,r.jsx)(n.h3,{id:"for-users",children:"For Users"}),"\n",(0,r.jsxs)(n.ol,{children:["\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.strong,{children:"Use Shift for proportions"}),": Hold Shift when dragging corners to maintain aspect ratio"]}),"\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.strong,{children:"Use Alt for center scale"}),": Scale from center for symmetrical adjustments"]}),"\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.strong,{children:"Rotate with Shift"}),": Hold Shift for precise 15\xb0 angle snapping"]}),"\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.strong,{children:"Check dimensions"}),": Look at tooltip feedback for exact sizes"]}),"\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.strong,{children:"Undo if needed"}),": Use Ctrl+Z to revert unwanted transformations"]}),"\n"]}),"\n",(0,r.jsx)(n.h3,{id:"for-plugin-developers",children:"For Plugin Developers"}),"\n",(0,r.jsxs)(n.ol,{children:["\n",(0,r.jsxs)(n.li,{children:["\n",(0,r.jsxs)(n.p,{children:[(0,r.jsx)(n.strong,{children:"Check transform state"})," before operations:"]}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-typescript",children:"const isTransforming = useCanvasStore.getState().transformation.isTransforming;\nif (isTransforming) {\n  // Wait for transform to complete\n  return;\n}\n"})}),"\n"]}),"\n",(0,r.jsxs)(n.li,{children:["\n",(0,r.jsxs)(n.p,{children:[(0,r.jsx)(n.strong,{children:"Subscribe to transform events"}),":"]}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-typescript",children:"eventBus.subscribe('elements:transformed', (payload) => {\n  console.log('Elements transformed:', payload.elementIds);\n});\n"})}),"\n"]}),"\n",(0,r.jsxs)(n.li,{children:["\n",(0,r.jsxs)(n.p,{children:[(0,r.jsx)(n.strong,{children:"Respect transformation bounds"}),":"]}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-typescript",children:"const bounds = state.getTransformationBounds?.();\nif (!bounds) {\n  console.warn('No transformation bounds available');\n  return;\n}\n"})}),"\n"]}),"\n",(0,r.jsxs)(n.li,{children:["\n",(0,r.jsxs)(n.p,{children:[(0,r.jsx)(n.strong,{children:"Apply scale limits"})," in custom transforms:"]}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-typescript",children:"const MIN_SCALE = 0.05;\nconst MAX_SCALE = 10.0;\nconst clampedScale = Math.max(MIN_SCALE, Math.min(MAX_SCALE, scale));\n"})}),"\n"]}),"\n"]}),"\n",(0,r.jsx)(n.hr,{}),"\n",(0,r.jsx)(n.h2,{id:"common-use-cases",children:"Common Use Cases"}),"\n",(0,r.jsx)(n.h3,{id:"resize-to-specific-dimensions",children:"Resize to Specific Dimensions"}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-typescript",children:"const state = useCanvasStore.getState();\n\n// Set exact width and height\nstate.applyResizeTransform?.(200, 150);\n\n// Proportional resize to width\nconst aspectRatio = bounds.height / bounds.width;\nstate.applyResizeTransform?.(200, 200 * aspectRatio);\n"})}),"\n",(0,r.jsx)(n.h3,{id:"rotate-to-specific-angle",children:"Rotate to Specific Angle"}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-typescript",children:"// Rotate to 45 degrees\nstate.applyRotationTransform?.(45);\n\n// Rotate by relative amount\nconst currentRotation = element.data?.transform?.rotation || 0;\nstate.applyRotationTransform?.(currentRotation + 90);\n"})}),"\n",(0,r.jsx)(n.h3,{id:"flip-horizontallyvertically",children:"Flip Horizontally/Vertically"}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-typescript",children:"// Horizontal flip (negative scaleX)\nconst bounds = state.getTransformationBounds?.();\ntransformElement(element, {\n  scaleX: -1,\n  scaleY: 1,\n  originX: bounds.x + bounds.width / 2,\n  originY: bounds.y + bounds.height / 2,\n  rotation: 0\n});\n\n// Vertical flip (negative scaleY)\ntransformElement(element, {\n  scaleX: 1,\n  scaleY: -1,\n  originX: bounds.x + bounds.width / 2,\n  originY: bounds.y + bounds.height / 2,\n  rotation: 0\n});\n"})}),"\n",(0,r.jsx)(n.hr,{}),"\n",(0,r.jsx)(n.h2,{id:"troubleshooting",children:"Troubleshooting"}),"\n",(0,r.jsx)(n.h3,{id:"transform-not-visible",children:"Transform not visible"}),"\n",(0,r.jsxs)(n.ul,{children:["\n",(0,r.jsx)(n.li,{children:"Ensure elements are selected"}),"\n",(0,r.jsx)(n.li,{children:"Check that Transform mode is active"}),"\n",(0,r.jsx)(n.li,{children:"Verify viewport zoom (handles may be too small/large)"}),"\n"]}),"\n",(0,r.jsx)(n.h3,{id:"proportional-scaling-not-working",children:"Proportional scaling not working"}),"\n",(0,r.jsxs)(n.ul,{children:["\n",(0,r.jsx)(n.li,{children:"Hold Shift key while dragging corner handles"}),"\n",(0,r.jsx)(n.li,{children:"Edge handles don't support proportional scaling"}),"\n"]}),"\n",(0,r.jsx)(n.h3,{id:"rotation-jumps-unexpectedly",children:"Rotation jumps unexpectedly"}),"\n",(0,r.jsxs)(n.ul,{children:["\n",(0,r.jsx)(n.li,{children:"Angle wraps at \xb1180\xb0 (expected behavior)"}),"\n",(0,r.jsx)(n.li,{children:"Release Shift if you don't want angle snapping"}),"\n"]}),"\n",(0,r.jsx)(n.h3,{id:"stroke-width-becomes-too-thickthin",children:"Stroke width becomes too thick/thin"}),"\n",(0,r.jsxs)(n.ul,{children:["\n",(0,r.jsx)(n.li,{children:"Stroke scales with element (expected behavior)"}),"\n",(0,r.jsx)(n.li,{children:"Use Edit mode to adjust stroke independently"}),"\n",(0,r.jsx)(n.li,{children:"Consider separating stroke into its own path"}),"\n"]}),"\n",(0,r.jsx)(n.hr,{}),"\n",(0,r.jsx)(n.h2,{id:"related-documentation",children:"Related Documentation"}),"\n",(0,r.jsxs)(n.ul,{children:["\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.a,{href:"/ttpe/docs/docs/plugins/catalog/transformation",children:"Transformation Plugin"})," - Plugin implementation"]}),"\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.a,{href:"/ttpe/docs/docs/features/selection",children:"Selection System"})," - Element selection"]}),"\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.a,{href:"../api/canvas-store",children:"Canvas Store API"})," - State management"]}),"\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.a,{href:"/ttpe/docs/docs/architecture/overview",children:"Transform Controller"})," - Transform math"]}),"\n"]})]})}function h(e={}){const{wrapper:n}={...(0,i.R)(),...e.components};return n?(0,r.jsx)(n,{...e,children:(0,r.jsx)(d,{...e})}):d(e)}}}]);