"use strict";(self.webpackChunkttpe_docs=self.webpackChunkttpe_docs||[]).push([[7802],{6081:(e,n,t)=>{t.r(n),t.d(n,{assets:()=>r,contentTitle:()=>o,default:()=>p,frontMatter:()=>l,metadata:()=>i,toc:()=>c});const i=JSON.parse('{"id":"plugins/overview","title":"Plugin System Overview","description":"The plugin system is TTPE\'s core extensibility mechanism. Every interactive tool and feature is implemented as a plugin, making the editor highly modular and maintainable.","source":"@site/docs/plugins/overview.md","sourceDirName":"plugins","slug":"/plugins/overview","permalink":"/ttpe/docs/plugins/overview","draft":false,"unlisted":false,"editUrl":"https://github.com/ekrsulov/ttpe/tree/main/doc/docs/plugins/overview.md","tags":[],"version":"current","lastUpdatedBy":"Ernesto Krsulovic","lastUpdatedAt":1762144179000,"frontMatter":{"id":"overview","title":"Plugin System Overview","sidebar_label":"Overview"},"sidebar":"docs","previous":{"title":"Diagrams","permalink":"/ttpe/docs/architecture/diagrams"},"next":{"title":"Lifecycle","permalink":"/ttpe/docs/plugins/lifecycle"}}');var a=t(4848),s=t(8453);const l={id:"overview",title:"Plugin System Overview",sidebar_label:"Overview"},o="Plugin System Overview",r={},c=[{value:"Philosophy",id:"philosophy",level:2},{value:"What is a Plugin?",id:"what-is-a-plugin",level:2},{value:"Plugin Definition Structure",id:"plugin-definition-structure",level:2},{value:"UI Contribution Types",id:"ui-contribution-types",level:3},{value:"Complete Plugin Example",id:"complete-plugin-example",level:2},{value:"Handler Context",id:"handler-context",level:2},{value:"Plugin Slice Pattern",id:"plugin-slice-pattern",level:2},{value:"Public API Pattern",id:"public-api-pattern",level:2},{value:"Canvas Layer Contributions",id:"canvas-layer-contributions",level:2},{value:"UI Contributions",id:"ui-contributions",level:2},{value:"Panels",id:"panels",level:3},{value:"Overlays",id:"overlays",level:3},{value:"Actions",id:"actions",level:3},{value:"Keyboard Shortcuts",id:"keyboard-shortcuts",level:2},{value:"Best Practices",id:"best-practices",level:2},{value:"1. Single Responsibility",id:"1-single-responsibility",level:3},{value:"2. State Isolation",id:"2-state-isolation",level:3},{value:"3. Cleanup",id:"3-cleanup",level:3},{value:"4. Type Safety",id:"4-type-safety",level:3},{value:"5. Performance",id:"5-performance",level:3},{value:"6. Accessibility",id:"6-accessibility",level:3},{value:"Common Patterns",id:"common-patterns",level:2},{value:"Pattern: Temporary State",id:"pattern-temporary-state",level:3},{value:"Pattern: Cross-Plugin Communication",id:"pattern-cross-plugin-communication",level:3},{value:"Pattern: Conditional Rendering",id:"pattern-conditional-rendering",level:3},{value:"Pitfalls &amp; Gotchas",id:"pitfalls--gotchas",level:2},{value:"1. Handler Scope",id:"1-handler-scope",level:3},{value:"2. Store Access",id:"2-store-access",level:3},{value:"3. Slice Registration Timing",id:"3-slice-registration-timing",level:3},{value:"4. API Initialization",id:"4-api-initialization",level:3},{value:"Next Steps",id:"next-steps",level:2}];function d(e){const n={a:"a",code:"code",h1:"h1",h2:"h2",h3:"h3",header:"header",li:"li",ol:"ol",p:"p",pre:"pre",strong:"strong",ul:"ul",...(0,s.R)(),...e.components};return(0,a.jsxs)(a.Fragment,{children:[(0,a.jsx)(n.header,{children:(0,a.jsx)(n.h1,{id:"plugin-system-overview",children:"Plugin System Overview"})}),"\n",(0,a.jsx)(n.p,{children:"The plugin system is TTPE's core extensibility mechanism. Every interactive tool and feature is implemented as a plugin, making the editor highly modular and maintainable."}),"\n",(0,a.jsx)(n.h2,{id:"philosophy",children:"Philosophy"}),"\n",(0,a.jsx)(n.p,{children:(0,a.jsx)(n.strong,{children:"Core provides infrastructure; plugins provide functionality."})}),"\n",(0,a.jsx)(n.p,{children:"The canvas, event bus, store, and plugin manager are infrastructure. Selection, drawing tools, transforms, and even the grid are all plugins that can be added, removed, or replaced without touching core code."}),"\n",(0,a.jsx)(n.h2,{id:"what-is-a-plugin",children:"What is a Plugin?"}),"\n",(0,a.jsx)(n.p,{children:"A plugin is a module that:"}),"\n",(0,a.jsxs)(n.ol,{children:["\n",(0,a.jsxs)(n.li,{children:[(0,a.jsx)(n.strong,{children:"Handles user interactions"})," when active (pointer events)"]}),"\n",(0,a.jsxs)(n.li,{children:[(0,a.jsx)(n.strong,{children:"Contributes UI"})," (panels, overlays, toolbar actions)"]}),"\n",(0,a.jsxs)(n.li,{children:[(0,a.jsx)(n.strong,{children:"Manages state"})," via Zustand slices"]}),"\n",(0,a.jsxs)(n.li,{children:[(0,a.jsx)(n.strong,{children:"Exposes APIs"})," for other plugins to call"]}),"\n",(0,a.jsxs)(n.li,{children:[(0,a.jsx)(n.strong,{children:"Responds to shortcuts"})," when active"]}),"\n",(0,a.jsxs)(n.li,{children:[(0,a.jsx)(n.strong,{children:"Renders on canvas"})," via layer contributions"]}),"\n"]}),"\n",(0,a.jsx)(n.h2,{id:"plugin-definition-structure",children:"Plugin Definition Structure"}),"\n",(0,a.jsxs)(n.p,{children:["Located in ",(0,a.jsx)(n.code,{children:"src/types/plugins.ts"}),":"]}),"\n",(0,a.jsx)(n.pre,{children:(0,a.jsx)(n.code,{className:"language-typescript",children:"interface PluginDefinition<TStore> {\n  // Required: Unique identifier\n  id: string;\n  \n  // Required: Display metadata\n  metadata: {\n    label: string;           // Human-readable name\n    icon?: React.ComponentType;    // Icon component\n    cursor?: string;         // CSS cursor (e.g., 'crosshair')\n  };\n  \n  // Optional: Pointer event handler\n  handler?: (\n    event: PointerEvent,\n    point: Point,\n    target: Element,\n    context: PluginHandlerContext<TStore>\n  ) => void;\n  \n  // Optional: Keyboard shortcuts\n  keyboardShortcuts?: CanvasShortcutMap;\n  \n  // Optional: UI contributions\n  overlays?: PluginUIContribution[];\n  canvasLayers?: CanvasLayerContribution[];\n  panels?: PluginUIContribution[];\n  actions?: PluginActionContribution[];\n  \n  // Optional: State management\n  slices?: PluginSliceFactory<TStore>[];\n  \n  // Optional: Public API\n  createApi?: PluginApiFactory<TStore>;\n}\n"})}),"\n",(0,a.jsx)(n.h3,{id:"ui-contribution-types",children:"UI Contribution Types"}),"\n",(0,a.jsx)(n.pre,{children:(0,a.jsx)(n.code,{className:"language-typescript",children:"// Panels and Overlays\ninterface PluginUIContribution<TProps = Record<string, unknown>> {\n  id: string;                         // Required: Unique identifier\n  component: React.ComponentType<TProps>;   // Required: React component\n  placement?: 'tool' | 'global';      // Optional: When to show\n}\n\n// Actions (Toolbar buttons)\ninterface PluginActionContribution<TProps = Record<string, unknown>> {\n  id: string;                         // Required: Unique identifier\n  component: React.ComponentType<TProps>;   // Required: React component\n  placement: 'top' | 'bottom';        // Required: Toolbar position\n}\n\n// Canvas Layers\ninterface CanvasLayerContribution {\n  id: string;                         // Required: Unique identifier\n  placement?: 'background' | 'midground' | 'foreground';\n  render: (context: CanvasLayerContext) => ReactNode;\n}\n"})}),"\n",(0,a.jsx)(n.pre,{children:(0,a.jsx)(n.code,{children:"\n## Minimal Plugin Example\n\n```typescript\n// src/plugins/my-tool/index.ts\nimport type { PluginDefinition } from '../../types/plugins';\nimport type { CanvasStore } from '../../store/canvasStore';\nimport { MyIcon } from 'lucide-react';\n\nexport const myToolPlugin: PluginDefinition<CanvasStore> = {\n  id: 'my-tool',\n  metadata: {\n    label: 'My Tool',\n    icon: MyIcon,\n    cursor: 'crosshair',\n  },\n  handler: (event, point, target, context) => {\n    console.log('User clicked at', point);\n    // Update state via context.store\n    const state = context.store.getState();\n    state.someAction?.(point);\n  },\n};\n"})}),"\n",(0,a.jsx)(n.h2,{id:"complete-plugin-example",children:"Complete Plugin Example"}),"\n",(0,a.jsx)(n.pre,{children:(0,a.jsx)(n.code,{className:"language-typescript",children:"// src/plugins/advanced-tool/index.ts\nimport type { PluginDefinition, PluginSliceFactory } from '../../types/plugins';\nimport type { CanvasStore } from '../../store/canvasStore';\nimport { AdvancedIcon } from 'lucide-react';\nimport { AdvancedPanel } from './AdvancedPanel';\nimport { AdvancedOverlay } from './AdvancedOverlay';\nimport { createAdvancedSlice } from './slice';\n\nexport const advancedToolPlugin: PluginDefinition<CanvasStore> = {\n  id: 'advanced-tool',\n  \n  metadata: {\n    label: 'Advanced Tool',\n    icon: AdvancedIcon,\n    cursor: 'pointer',\n  },\n  \n  handler: (event, point, target, context) => {\n    const { store, api, helpers } = context;\n    const state = store.getState();\n    \n    // Access plugin's own slice\n    if (state.advancedTool) {\n      state.advancedTool.processPoint(point);\n    }\n    \n    // Use helpers provided by canvas\n    if (helpers.beginSelectionRectangle) {\n      helpers.beginSelectionRectangle(point);\n    }\n  },\n  \n  keyboardShortcuts: {\n    a: (event, context) => {\n      if (event.ctrlKey || event.metaKey) {\n        event.preventDefault();\n        const state = context.store.getState();\n        state.advancedTool?.selectAll();\n      }\n    },\n    Escape: (_event, context) => {\n      const state = context.store.getState();\n      state.advancedTool?.reset();\n    },\n  },\n  \n  overlays: [\n    {\n      id: 'advanced-tool-overlay',\n      placement: 'tool', // Only shows when this tool is active\n      component: AdvancedOverlay,\n    },\n  ],\n  \n  panels: [\n    {\n      id: 'advanced-tool-panel',\n      placement: 'tool',\n      component: AdvancedPanel,\n    },\n  ],\n  \n  canvasLayers: [\n    {\n      id: 'advanced-tool-layer',\n      placement: 'foreground',\n      render: (context) => {\n        // Custom SVG rendering\n        return (\n          <g id=\"advanced-layer\">\n            <circle cx={100} cy={100} r={50} fill=\"blue\" opacity={0.3} />\n          </g>\n        );\n      },\n    },\n  ],\n  \n  actions: [\n    {\n      id: 'advanced-action',\n      placement: 'bottom',  // 'top' or 'bottom' only\n      component: () => (\n        <ToolbarIconButton\n          icon={AdvancedIcon}\n          label=\"Advanced Action\"\n          onClick={() => {\n            const state = useCanvasStore.getState();\n            state.advancedTool?.performAction();\n          }}\n        />\n      ),\n    },\n  ],\n  \n  slices: [createAdvancedSlice],\n  \n  createApi: (context) => ({\n    doSomething: (arg: string) => {\n      console.log('Public API called with', arg);\n      const state = context.store.getState();\n      state.advancedTool?.doSomething(arg);\n    },\n    getSomething: () => {\n      const state = context.store.getState();\n      return state.advancedTool?.data ?? null;\n    },\n  }),\n};\n"})}),"\n",(0,a.jsx)(n.h2,{id:"handler-context",children:"Handler Context"}),"\n",(0,a.jsxs)(n.p,{children:["When a plugin's handler is called, it receives a ",(0,a.jsx)(n.code,{children:"PluginHandlerContext"}),":"]}),"\n",(0,a.jsx)(n.pre,{children:(0,a.jsx)(n.code,{className:"language-typescript",children:"interface PluginHandlerContext<TStore> {\n  // Zustand store access\n  store: {\n    getState: () => TStore;\n    setState: (partial: Partial<TStore>) => void;\n    subscribe: (listener: (state: TStore) => void) => () => void;\n  };\n  \n  // Plugin's own public API (from createApi)\n  api: Record<string, (...args: any[]) => any>;\n  \n  // Canvas helpers\n  helpers: {\n    beginSelectionRectangle?: (point: Point, shiftKey?: boolean) => void;\n    updateSelectionRectangle?: (point: Point) => void;\n    completeSelectionRectangle?: () => void;\n    startShapeCreation?: (point: Point) => void;\n    updateShapeCreation?: (point: Point, shiftPressed: boolean) => void;\n    endShapeCreation?: () => void;\n    isSmoothBrushActive?: boolean;\n    // Extensible: other helpers can be added\n  };\n}\n"})}),"\n",(0,a.jsx)(n.h2,{id:"plugin-slice-pattern",children:"Plugin Slice Pattern"}),"\n",(0,a.jsx)(n.p,{children:"Plugins contribute state via slices:"}),"\n",(0,a.jsx)(n.pre,{children:(0,a.jsx)(n.code,{className:"language-typescript",children:"// src/plugins/my-tool/slice.ts\nimport type { StateCreator } from 'zustand';\nimport type { PluginSliceFactory } from '../../types/plugins';\n\nexport interface MyToolSlice {\n  myData: string[];\n  mySettings: { enabled: boolean };\n  addData: (item: string) => void;\n  clearData: () => void;\n}\n\nexport const createMyToolSlice: PluginSliceFactory = (set, get, api) => ({\n  state: {\n    myData: [],\n    mySettings: { enabled: true },\n    addData: (item) => set((state) => ({ \n      myData: [...state.myData, item] \n    })),\n    clearData: () => set({ myData: [] }),\n  },\n  cleanup: (set, get, api) => {\n    // Optional: cleanup when plugin is unregistered\n    console.log('Cleaning up my tool slice');\n  },\n});\n"})}),"\n",(0,a.jsx)(n.h2,{id:"public-api-pattern",children:"Public API Pattern"}),"\n",(0,a.jsx)(n.p,{children:"Plugins can expose APIs for other plugins to call:"}),"\n",(0,a.jsx)(n.pre,{children:(0,a.jsx)(n.code,{className:"language-typescript",children:"// In plugin definition\ncreateApi: (context) => ({\n  // Public method\n  calculateSomething: (input: number): number => {\n    const state = context.store.getState();\n    return input * 2 + (state.myTool?.multiplier ?? 1);\n  },\n  \n  // Public getter\n  isReady: (): boolean => {\n    const state = context.store.getState();\n    return state.myTool?.initialized ?? false;\n  },\n});\n\n// In another plugin or component\nconst api = pluginManager.getPluginApi<MyToolAPI>('my-tool');\nif (api) {\n  const result = api.calculateSomething(42);\n  console.log(result);\n}\n\n// Or via plugin manager proxy\npluginManager.callPluginApi('my-tool', 'calculateSomething', 42);\n"})}),"\n",(0,a.jsx)(n.h2,{id:"canvas-layer-contributions",children:"Canvas Layer Contributions"}),"\n",(0,a.jsx)(n.p,{children:"Plugins can render custom SVG layers:"}),"\n",(0,a.jsx)(n.pre,{children:(0,a.jsx)(n.code,{className:"language-typescript",children:"canvasLayers: [\n  {\n    id: 'my-layer',\n    placement: 'midground', // 'background' | 'midground' | 'foreground'\n    render: (context: CanvasLayerContext) => {\n      const { \n        elements, \n        selectedIds, \n        activePlugin, \n        viewport, \n        isElementHidden, \n        getElementBounds \n      } = context;\n      \n      // Only render if this plugin is active\n      if (activePlugin !== 'my-tool') return null;\n      \n      return (\n        <g id=\"my-custom-layer\">\n          {selectedIds.map(id => {\n            const el = elements.find(e => e.id === id);\n            if (!el) return null;\n            \n            const bounds = getElementBounds(el);\n            return (\n              <rect\n                key={id}\n                x={bounds.x}\n                y={bounds.y}\n                width={bounds.width}\n                height={bounds.height}\n                fill=\"none\"\n                stroke=\"blue\"\n                strokeWidth={2 / viewport.zoom}\n              />\n            );\n          })}\n        </g>\n      );\n    },\n  },\n],\n"})}),"\n",(0,a.jsx)(n.h2,{id:"ui-contributions",children:"UI Contributions"}),"\n",(0,a.jsx)(n.h3,{id:"panels",children:"Panels"}),"\n",(0,a.jsx)(n.p,{children:"Sidebar panels that appear when the tool is active:"}),"\n",(0,a.jsx)(n.pre,{children:(0,a.jsx)(n.code,{className:"language-typescript",children:"panels: [\n  {\n    placement: 'tool', // or 'global' for always-visible\n    component: MyToolPanel,\n  },\n],\n\n// MyToolPanel.tsx\nexport const MyToolPanel: React.FC = () => {\n  const myData = useCanvasStore(state => state.myTool?.myData);\n  \n  return (\n    <Panel title=\"My Tool Settings\">\n      <div>Data count: {myData?.length ?? 0}</div>\n    </Panel>\n  );\n};\n"})}),"\n",(0,a.jsx)(n.h3,{id:"overlays",children:"Overlays"}),"\n",(0,a.jsx)(n.p,{children:"React components rendered above the canvas:"}),"\n",(0,a.jsx)(n.pre,{children:(0,a.jsx)(n.code,{className:"language-typescript",children:"overlays: [\n  {\n    placement: 'global', // or 'tool'\n    component: MyToolOverlay,\n  },\n],\n\n// MyToolOverlay.tsx\nexport const MyToolOverlay: React.FC = () => {\n  const isActive = useCanvasStore(state => state.activePlugin === 'my-tool');\n  if (!isActive) return null;\n  \n  return (\n    <div style={{ position: 'absolute', top: 10, right: 10 }}>\n      <Badge>My Tool Active</Badge>\n    </div>\n  );\n};\n"})}),"\n",(0,a.jsx)(n.h3,{id:"actions",children:"Actions"}),"\n",(0,a.jsx)(n.p,{children:"Toolbar buttons and menu items:"}),"\n",(0,a.jsx)(n.pre,{children:(0,a.jsx)(n.code,{className:"language-typescript",children:"actions: [\n  {\n    id: 'my-action',\n    placement: 'bottom-toolbar', // or 'top-toolbar', 'context-menu'\n    label: 'Do Something',\n    icon: MyIcon,\n    shortcut: 'Ctrl+Shift+M',\n    onClick: (context) => {\n      context.store.getState().myTool?.doSomething();\n    },\n    isDisabled: (context) => {\n      const state = context.store.getState();\n      return !state.myTool?.canDoSomething;\n    },\n  },\n],\n"})}),"\n",(0,a.jsx)(n.h2,{id:"keyboard-shortcuts",children:"Keyboard Shortcuts"}),"\n",(0,a.jsx)(n.p,{children:"Plugins can register shortcuts that only work when the plugin is active:"}),"\n",(0,a.jsx)(n.pre,{children:(0,a.jsx)(n.code,{className:"language-typescript",children:"keyboardShortcuts: {\n  // Simple key\n  a: (event, context) => {\n    if (event.ctrlKey) {\n      event.preventDefault();\n      // Select all logic\n    }\n  },\n  \n  // Named keys\n  Delete: (event, context) => {\n    const state = context.store.getState();\n    state.myTool?.deleteSelected();\n  },\n  \n  Escape: (event, context) => {\n    const state = context.store.getState();\n    state.myTool?.reset();\n  },\n  \n  // Arrow keys\n  ArrowUp: (event, context) => {\n    if (event.shiftKey) {\n      // Move faster\n    } else {\n      // Move normal\n    }\n  },\n},\n"})}),"\n",(0,a.jsx)(n.h2,{id:"best-practices",children:"Best Practices"}),"\n",(0,a.jsx)(n.h3,{id:"1-single-responsibility",children:"1. Single Responsibility"}),"\n",(0,a.jsx)(n.p,{children:"Each plugin should do one thing well. Don't combine selection + drawing in one plugin."}),"\n",(0,a.jsx)(n.h3,{id:"2-state-isolation",children:"2. State Isolation"}),"\n",(0,a.jsx)(n.p,{children:"Plugin state should live in the plugin's slice, not pollute the base slice."}),"\n",(0,a.jsx)(n.pre,{children:(0,a.jsx)(n.code,{className:"language-typescript",children:"// \u2705 Good\nconst myData = useCanvasStore(state => state.myPlugin?.myData);\n\n// \u274c Bad\nconst myData = useCanvasStore(state => state.myPluginData);\n"})}),"\n",(0,a.jsx)(n.h3,{id:"3-cleanup",children:"3. Cleanup"}),"\n",(0,a.jsx)(n.p,{children:"If your plugin adds event listeners, intervals, or subscriptions, clean them up:"}),"\n",(0,a.jsx)(n.pre,{children:(0,a.jsx)(n.code,{className:"language-typescript",children:"slices: [\n  (set, get, api) => ({\n    state: { /* ... */ },\n    cleanup: () => {\n      // Remove event listeners, clear intervals, etc.\n    },\n  }),\n],\n"})}),"\n",(0,a.jsx)(n.h3,{id:"4-type-safety",children:"4. Type Safety"}),"\n",(0,a.jsx)(n.p,{children:"Always type your plugin APIs and slices:"}),"\n",(0,a.jsx)(n.pre,{children:(0,a.jsx)(n.code,{className:"language-typescript",children:"export interface MyPluginAPI {\n  doSomething: (arg: string) => void;\n  getSomething: () => string | null;\n}\n\ncreateApi: (context): MyPluginAPI => ({ /* ... */ }),\n"})}),"\n",(0,a.jsx)(n.h3,{id:"5-performance",children:"5. Performance"}),"\n",(0,a.jsxs)(n.ul,{children:["\n",(0,a.jsxs)(n.li,{children:["Memoize expensive computations in ",(0,a.jsx)(n.code,{children:"render"})," functions"]}),"\n",(0,a.jsxs)(n.li,{children:["Use ",(0,a.jsx)(n.code,{children:"useCallback"})," and ",(0,a.jsx)(n.code,{children:"useMemo"})," in panel components"]}),"\n",(0,a.jsx)(n.li,{children:"Debounce high-frequency updates"}),"\n"]}),"\n",(0,a.jsx)(n.h3,{id:"6-accessibility",children:"6. Accessibility"}),"\n",(0,a.jsxs)(n.ul,{children:["\n",(0,a.jsxs)(n.li,{children:["Provide ",(0,a.jsx)(n.code,{children:"aria-label"})," on UI elements"]}),"\n",(0,a.jsx)(n.li,{children:"Ensure keyboard navigation works"}),"\n",(0,a.jsx)(n.li,{children:"Test with screen readers"}),"\n"]}),"\n",(0,a.jsx)(n.h2,{id:"common-patterns",children:"Common Patterns"}),"\n",(0,a.jsx)(n.h3,{id:"pattern-temporary-state",children:"Pattern: Temporary State"}),"\n",(0,a.jsx)(n.p,{children:"For state that doesn't need persistence or undo:"}),"\n",(0,a.jsx)(n.pre,{children:(0,a.jsx)(n.code,{className:"language-typescript",children:"// Use React state in panels\nconst [tempValue, setTempValue] = useState(0);\n\n// Or use a separate Zustand store\nconst useTempStore = create(() => ({ temp: 0 }));\n"})}),"\n",(0,a.jsx)(n.h3,{id:"pattern-cross-plugin-communication",children:"Pattern: Cross-Plugin Communication"}),"\n",(0,a.jsx)(n.pre,{children:(0,a.jsx)(n.code,{className:"language-typescript",children:"// Via shared store\nconst state = context.store.getState();\nstate.otherPlugin?.doSomething();\n\n// Via plugin API\nconst api = pluginManager.getPluginApi('other-plugin');\napi?.doSomething();\n\n// Via event bus\npluginManager.registerInteractionHandler(\n  'my-plugin',\n  'pointermove',\n  (payload) => {\n    console.log('Pointer moved', payload.point);\n  }\n);\n"})}),"\n",(0,a.jsx)(n.h3,{id:"pattern-conditional-rendering",children:"Pattern: Conditional Rendering"}),"\n",(0,a.jsx)(n.pre,{children:(0,a.jsx)(n.code,{className:"language-typescript",children:"canvasLayers: [\n  {\n    id: 'conditional',\n    placement: 'foreground',\n    render: (context) => {\n      const state = useCanvasStore.getState();\n      \n      // Only render when certain conditions are met\n      if (!state.myPlugin?.showOverlay) return null;\n      if (context.activePlugin !== 'my-plugin') return null;\n      \n      return <g>{/* ... */}</g>;\n    },\n  },\n],\n"})}),"\n",(0,a.jsx)(n.h2,{id:"pitfalls--gotchas",children:"Pitfalls & Gotchas"}),"\n",(0,a.jsx)(n.h3,{id:"1-handler-scope",children:"1. Handler Scope"}),"\n",(0,a.jsxs)(n.p,{children:["Handlers receive the ",(0,a.jsx)(n.strong,{children:"active plugin ID"})," in the payload. Filter early:"]}),"\n",(0,a.jsx)(n.pre,{children:(0,a.jsx)(n.code,{className:"language-typescript",children:"handler: (event, point, target, context) => {\n  // This check is done by PluginManager when using event bus\n  // But if you manually call executeHandler, ensure plugin is active\n}\n"})}),"\n",(0,a.jsx)(n.h3,{id:"2-store-access",children:"2. Store Access"}),"\n",(0,a.jsxs)(n.p,{children:["Always use ",(0,a.jsx)(n.code,{children:"context.store.getState()"})," for latest state, not closure variables:"]}),"\n",(0,a.jsx)(n.pre,{children:(0,a.jsx)(n.code,{className:"language-typescript",children:"// \u274c Stale closure\nconst elements = context.store.getState().elements;\nsetTimeout(() => {\n  console.log(elements); // Stale!\n}, 1000);\n\n// \u2705 Fresh state\nsetTimeout(() => {\n  const elements = context.store.getState().elements;\n  console.log(elements); // Fresh!\n}, 1000);\n"})}),"\n",(0,a.jsx)(n.h3,{id:"3-slice-registration-timing",children:"3. Slice Registration Timing"}),"\n",(0,a.jsxs)(n.p,{children:["Slices are registered when ",(0,a.jsx)(n.code,{children:"pluginManager.register()"})," is called. Access slice state ",(0,a.jsx)(n.strong,{children:"after"})," registration:"]}),"\n",(0,a.jsx)(n.pre,{children:(0,a.jsx)(n.code,{className:"language-typescript",children:"pluginManager.register(myPlugin);\n\n// \u2705 Now you can access state\nconst state = useCanvasStore.getState();\nconsole.log(state.myPlugin);\n"})}),"\n",(0,a.jsx)(n.h3,{id:"4-api-initialization",children:"4. API Initialization"}),"\n",(0,a.jsxs)(n.p,{children:["Plugin APIs are initialized ",(0,a.jsx)(n.strong,{children:"after"})," store is set. Don't call APIs during plugin registration:"]}),"\n",(0,a.jsx)(n.pre,{children:(0,a.jsx)(n.code,{className:"language-typescript",children:"// \u274c API not ready yet\npluginManager.register(pluginA);\nconst api = pluginManager.getPluginApi('pluginA'); // undefined!\n\n// \u2705 Call after all plugins registered\npluginManager.register(pluginA);\npluginManager.setStoreApi(storeApi); // Initialize APIs\nconst api = pluginManager.getPluginApi('pluginA'); // \u2705\n"})}),"\n",(0,a.jsx)(n.h2,{id:"next-steps",children:"Next Steps"}),"\n",(0,a.jsxs)(n.ul,{children:["\n",(0,a.jsxs)(n.li,{children:[(0,a.jsx)(n.strong,{children:(0,a.jsx)(n.a,{href:"./lifecycle",children:"Plugin Lifecycle"})}),": Detailed lifecycle states and transitions"]}),"\n",(0,a.jsxs)(n.li,{children:[(0,a.jsx)(n.strong,{children:(0,a.jsx)(n.a,{href:"./registration",children:"Plugin Registration"})}),": How to register and discover plugins"]}),"\n",(0,a.jsxs)(n.li,{children:[(0,a.jsx)(n.strong,{children:(0,a.jsx)(n.a,{href:"./configuration",children:"Plugin Configuration"})}),": Advanced configuration options"]}),"\n",(0,a.jsxs)(n.li,{children:[(0,a.jsx)(n.strong,{children:(0,a.jsx)(n.a,{href:"./catalog/select",children:"Plugin Catalog"})}),": Reference for all built-in plugins"]}),"\n"]})]})}function p(e={}){const{wrapper:n}={...(0,s.R)(),...e.components};return n?(0,a.jsx)(n,{...e,children:(0,a.jsx)(d,{...e})}):d(e)}},8453:(e,n,t)=>{t.d(n,{R:()=>l,x:()=>o});var i=t(6540);const a={},s=i.createContext(a);function l(e){const n=i.useContext(s);return i.useMemo(function(){return"function"==typeof e?e(n):{...n,...e}},[n,e])}function o(e){let n;return n=e.disableParentContext?"function"==typeof e.components?e.components(a):e.components||a:l(e.components),i.createElement(s.Provider,{value:n},e.children)}}}]);