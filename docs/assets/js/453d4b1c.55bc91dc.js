"use strict";(self.webpackChunkttpe_docs=self.webpackChunkttpe_docs||[]).push([[1565],{5219:(e,n,t)=>{t.r(n),t.d(n,{assets:()=>l,contentTitle:()=>a,default:()=>h,frontMatter:()=>i,metadata:()=>s,toc:()=>d});const s=JSON.parse('{"id":"features/undo-redo","title":"Undo/Redo","description":"The undo/redo system provides comprehensive history management for all canvas operations, allowing users to step backward and forward through their editing history. Built on Zundo middleware for Zustand, the system intelligently tracks state changes with automatic snapshot creation, cooldown periods to prevent excessive history entries, and selective state tracking to optimize memory usage.","source":"@site/docs/features/undo-redo.md","sourceDirName":"features","slug":"/features/undo-redo","permalink":"/ttpe/docs/features/undo-redo","draft":false,"unlisted":false,"editUrl":"https://github.com/ekrsulov/ttpe/tree/main/doc/docs/features/undo-redo.md","tags":[],"version":"current","lastUpdatedBy":"Ernesto Krsulovic","lastUpdatedAt":1762144179000,"frontMatter":{"id":"undo-redo","title":"Undo/Redo","sidebar_label":"Undo/Redo"},"sidebar":"docs","previous":{"title":"Groups","permalink":"/ttpe/docs/features/groups"},"next":{"title":"Persistence","permalink":"/ttpe/docs/features/persistence"}}');var r=t(4848),o=t(8453);const i={id:"undo-redo",title:"Undo/Redo",sidebar_label:"Undo/Redo"},a="Undo/Redo",l={},d=[{value:"Overview",id:"overview",level:2},{value:"Temporal State Architecture",id:"temporal-state-architecture",level:2},{value:"Configuration",id:"configuration",level:2},{value:"Configuration Parameters",id:"configuration-parameters",level:3},{value:"What&#39;s Tracked vs. Not Tracked",id:"whats-tracked-vs-not-tracked",level:2},{value:"Tracked State (Included in History)",id:"tracked-state-included-in-history",level:3},{value:"Not Tracked (Excluded from History)",id:"not-tracked-excluded-from-history",level:3},{value:"Undo/Redo Flow",id:"undoredo-flow",level:2},{value:"Usage",id:"usage",level:2},{value:"Keyboard Shortcuts",id:"keyboard-shortcuts",level:3},{value:"UI Controls",id:"ui-controls",level:3},{value:"API Reference",id:"api-reference",level:2},{value:"Accessing Temporal State",id:"accessing-temporal-state",level:3},{value:"Temporal Methods",id:"temporal-methods",level:3},{value:"<code>undo()</code>",id:"undo",level:4},{value:"<code>redo()</code>",id:"redo",level:4},{value:"<code>clear()</code>",id:"clear",level:4},{value:"Temporal State Properties",id:"temporal-state-properties",level:3},{value:"<code>pastStates</code>",id:"paststates",level:4},{value:"<code>futureStates</code>",id:"futurestates",level:4},{value:"Usage Examples",id:"usage-examples",level:2},{value:"Basic Undo/Redo",id:"basic-undoredo",level:3},{value:"Check History Availability",id:"check-history-availability",level:3},{value:"Clear History on Document Load",id:"clear-history-on-document-load",level:3},{value:"Custom Undo Hook",id:"custom-undo-hook",level:3},{value:"Cooldown Period Explained",id:"cooldown-period-explained",level:2},{value:"Best Practices",id:"best-practices",level:2},{value:"For Users",id:"for-users",level:3},{value:"For Plugin Developers",id:"for-plugin-developers",level:3},{value:"Limitations",id:"limitations",level:2},{value:"Related Documentation",id:"related-documentation",level:2}];function c(e){const n={a:"a",code:"code",h1:"h1",h2:"h2",h3:"h3",h4:"h4",header:"header",li:"li",mermaid:"mermaid",ol:"ol",p:"p",pre:"pre",strong:"strong",table:"table",tbody:"tbody",td:"td",th:"th",thead:"thead",tr:"tr",ul:"ul",...(0,o.R)(),...e.components};return(0,r.jsxs)(r.Fragment,{children:[(0,r.jsx)(n.header,{children:(0,r.jsx)(n.h1,{id:"undoredo",children:"Undo/Redo"})}),"\n",(0,r.jsxs)(n.p,{children:["The undo/redo system provides comprehensive history management for all canvas operations, allowing users to step backward and forward through their editing history. Built on ",(0,r.jsx)(n.strong,{children:"Zundo"})," middleware for Zustand, the system intelligently tracks state changes with automatic snapshot creation, cooldown periods to prevent excessive history entries, and selective state tracking to optimize memory usage."]}),"\n",(0,r.jsx)(n.p,{children:"Undo/redo is critical for confident editing workflows, enabling users to experiment freely knowing they can revert mistakes. The system integrates seamlessly with all canvas operations while excluding transient UI state and viewport changes that shouldn't clutter the history stack."}),"\n",(0,r.jsx)(n.h2,{id:"overview",children:"Overview"}),"\n",(0,r.jsxs)(n.p,{children:["The undo/redo system is implemented using ",(0,r.jsx)(n.strong,{children:"Zundo"}),", a temporal middleware for Zustand that wraps the store and maintains parallel ",(0,r.jsx)(n.strong,{children:"past"})," and ",(0,r.jsx)(n.strong,{children:"future"})," state stacks. When a user performs an action, the current state is pushed to the past stack, and the future stack is cleared. Undoing pops from past and pushes to future; redoing reverses this process."]}),"\n",(0,r.jsx)(n.p,{children:(0,r.jsx)(n.strong,{children:"Key characteristics:"})}),"\n",(0,r.jsxs)(n.ul,{children:["\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.strong,{children:"Automatic snapshots"}),": State changes trigger automatic history snapshots"]}),"\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.strong,{children:"Cooldown period"}),": 100ms debounce prevents excessive snapshots during rapid actions"]}),"\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.strong,{children:"Selective tracking"}),": Only essential state (elements, selection, viewport) is tracked"]}),"\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.strong,{children:"Deep equality check"}),": Prevents duplicate snapshots when state hasn't truly changed"]}),"\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.strong,{children:"Memory limited"}),": Maintains last 50 steps to prevent unbounded growth"]}),"\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.strong,{children:"Non-blocking"}),": Operates without blocking UI or user interactions"]}),"\n"]}),"\n",(0,r.jsx)(n.h2,{id:"temporal-state-architecture",children:"Temporal State Architecture"}),"\n",(0,r.jsx)(n.mermaid,{value:"stateDiagram-v2\n    [*] --\x3e Present: Initial state\n    \n    Present --\x3e Past: Action performed<br/>(snapshot created)\n    Past --\x3e Present: Undo (Ctrl+Z)<br/>(restore previous)\n    Present --\x3e Future: Undo executed<br/>(save current to future)\n    Future --\x3e Present: Redo (Ctrl+Shift+Z)<br/>(restore next)\n    \n    Present --\x3e Present: Action (cooldown active)<br/>(no snapshot)\n    \n    state Past {\n        [*] --\x3e P1: First action\n        P1 --\x3e P2: Second action\n        P2 --\x3e P3: Third action\n        P3 --\x3e Pn: ...more actions\n        Pn --\x3e [Limit 50]\n    }\n    \n    state Future {\n        [*] --\x3e F1: First redo available\n        F1 --\x3e F2: Second redo available\n        F2 --\x3e Fn: ...more redos\n    }\n    \n    note right of Past\n        pastStates[] array\n        Max 50 entries\n        Oldest removed on overflow\n    end note\n    \n    note right of Future\n        futureStates[] array\n        Cleared on new action\n        Available after undo\n    end note"}),"\n",(0,r.jsx)(n.p,{children:(0,r.jsx)(n.strong,{children:"State transitions:"})}),"\n",(0,r.jsxs)(n.ol,{children:["\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.strong,{children:"Action performed"}),": ",(0,r.jsx)(n.code,{children:"present"})," \u2192 ",(0,r.jsx)(n.code,{children:"past"}),", ",(0,r.jsx)(n.code,{children:"future"})," cleared"]}),"\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.strong,{children:"Undo (Ctrl+Z)"}),": ",(0,r.jsx)(n.code,{children:"past.pop()"})," \u2192 ",(0,r.jsx)(n.code,{children:"present"}),", old ",(0,r.jsx)(n.code,{children:"present"})," \u2192 ",(0,r.jsx)(n.code,{children:"future.push()"})]}),"\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.strong,{children:"Redo (Ctrl+Shift+Z)"}),": ",(0,r.jsx)(n.code,{children:"future.pop()"})," \u2192 ",(0,r.jsx)(n.code,{children:"present"}),", old ",(0,r.jsx)(n.code,{children:"present"})," \u2192 ",(0,r.jsx)(n.code,{children:"past.push()"})]}),"\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.strong,{children:"Within cooldown"}),": State change ignored, no snapshot created"]}),"\n"]}),"\n",(0,r.jsx)(n.h2,{id:"configuration",children:"Configuration"}),"\n",(0,r.jsxs)(n.p,{children:["The undo/redo system is configured in ",(0,r.jsx)(n.code,{children:"src/store/canvasStore.ts"})," with the following parameters:"]}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-typescript",children:"const useCanvasStore = create<CanvasStore>()(\n  persist(\n    temporal(\n      (...args) => ({\n        ...createBaseSlice(...args),\n        ...createViewportSlice(...args),\n        ...createSelectionSlice(...args),\n        // ... other slices\n      }),\n      {\n        // Maximum history depth: keep last 50 state snapshots\n        limit: 50,\n        \n        // Selective state: only track essential fields\n        partialize: (state) => ({\n          elements: state.elements,\n          selectedIds: state.selectedIds,\n          viewport: state.viewport,\n        }),\n        \n        // Deep equality check to prevent duplicate snapshots\n        equality: (pastState, currentState) => isDeepEqual(pastState, currentState),\n        \n        // Cooldown period: 100ms debounce for rapid changes\n        handleSet: (handleSet) =>\n          debounce<typeof handleSet>((state) => {\n            handleSet(state);\n          }, 100),\n      }\n    ),\n    {\n      name: 'canvas-app-state',\n      // ... persistence config\n    }\n  )\n);\n"})}),"\n",(0,r.jsx)(n.h3,{id:"configuration-parameters",children:"Configuration Parameters"}),"\n",(0,r.jsxs)(n.table,{children:[(0,r.jsx)(n.thead,{children:(0,r.jsxs)(n.tr,{children:[(0,r.jsx)(n.th,{children:"Parameter"}),(0,r.jsx)(n.th,{children:"Value"}),(0,r.jsx)(n.th,{children:"Purpose"})]})}),(0,r.jsxs)(n.tbody,{children:[(0,r.jsxs)(n.tr,{children:[(0,r.jsx)(n.td,{children:(0,r.jsx)(n.code,{children:"limit"})}),(0,r.jsx)(n.td,{children:(0,r.jsx)(n.code,{children:"50"})}),(0,r.jsx)(n.td,{children:"Maximum number of history snapshots to retain"})]}),(0,r.jsxs)(n.tr,{children:[(0,r.jsx)(n.td,{children:(0,r.jsx)(n.code,{children:"partialize"})}),(0,r.jsx)(n.td,{children:(0,r.jsx)(n.code,{children:"{ elements, selectedIds, viewport }"})}),(0,r.jsx)(n.td,{children:"Which state fields to track in history"})]}),(0,r.jsxs)(n.tr,{children:[(0,r.jsx)(n.td,{children:(0,r.jsx)(n.code,{children:"equality"})}),(0,r.jsx)(n.td,{children:(0,r.jsx)(n.code,{children:"isDeepEqual()"})}),(0,r.jsx)(n.td,{children:"Deep equality check to skip duplicate snapshots"})]}),(0,r.jsxs)(n.tr,{children:[(0,r.jsx)(n.td,{children:(0,r.jsx)(n.code,{children:"handleSet"})}),(0,r.jsx)(n.td,{children:(0,r.jsx)(n.code,{children:"debounce(100ms)"})}),(0,r.jsx)(n.td,{children:"Cooldown period between snapshots"})]})]})]}),"\n",(0,r.jsx)(n.h2,{id:"whats-tracked-vs-not-tracked",children:"What's Tracked vs. Not Tracked"}),"\n",(0,r.jsx)(n.h3,{id:"tracked-state-included-in-history",children:"Tracked State (Included in History)"}),"\n",(0,r.jsxs)(n.p,{children:["The following state changes ",(0,r.jsx)(n.strong,{children:"trigger undo/redo snapshots"}),":"]}),"\n",(0,r.jsxs)(n.ul,{children:["\n",(0,r.jsxs)(n.li,{children:["\n",(0,r.jsxs)(n.p,{children:[(0,r.jsx)(n.strong,{children:"Canvas elements"}),": All path, group, and shape modifications"]}),"\n",(0,r.jsxs)(n.ul,{children:["\n",(0,r.jsx)(n.li,{children:"Element creation/deletion"}),"\n",(0,r.jsx)(n.li,{children:"Property changes (position, size, rotation, style)"}),"\n",(0,r.jsx)(n.li,{children:"Path data modifications (commands, points)"}),"\n"]}),"\n"]}),"\n",(0,r.jsxs)(n.li,{children:["\n",(0,r.jsxs)(n.p,{children:[(0,r.jsx)(n.strong,{children:"Selection state"}),": Which elements are currently selected"]}),"\n",(0,r.jsxs)(n.ul,{children:["\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.code,{children:"selectedIds"})," array changes"]}),"\n",(0,r.jsx)(n.li,{children:"Selection mode transitions"}),"\n"]}),"\n"]}),"\n",(0,r.jsxs)(n.li,{children:["\n",(0,r.jsxs)(n.p,{children:[(0,r.jsx)(n.strong,{children:"Viewport state"}),": Pan and zoom (included for context)"]}),"\n",(0,r.jsxs)(n.ul,{children:["\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.code,{children:"viewport.panX"}),", ",(0,r.jsx)(n.code,{children:"viewport.panY"})]}),"\n",(0,r.jsx)(n.li,{children:(0,r.jsx)(n.code,{children:"viewport.zoom"})}),"\n"]}),"\n"]}),"\n"]}),"\n",(0,r.jsx)(n.h3,{id:"not-tracked-excluded-from-history",children:"Not Tracked (Excluded from History)"}),"\n",(0,r.jsxs)(n.p,{children:["The following state changes ",(0,r.jsx)(n.strong,{children:"do not trigger snapshots"}),":"]}),"\n",(0,r.jsxs)(n.ul,{children:["\n",(0,r.jsxs)(n.li,{children:["\n",(0,r.jsxs)(n.p,{children:[(0,r.jsx)(n.strong,{children:"Transient UI state"}),": Temporary interaction states"]}),"\n",(0,r.jsxs)(n.ul,{children:["\n",(0,r.jsx)(n.li,{children:"Hover highlights"}),"\n",(0,r.jsx)(n.li,{children:"Drag previews"}),"\n",(0,r.jsx)(n.li,{children:"Selection rectangle during drag"}),"\n",(0,r.jsx)(n.li,{children:"Active tool indicators"}),"\n"]}),"\n"]}),"\n",(0,r.jsxs)(n.li,{children:["\n",(0,r.jsxs)(n.p,{children:[(0,r.jsx)(n.strong,{children:"Plugin-specific ephemeral state"}),": Temporary plugin data"]}),"\n",(0,r.jsxs)(n.ul,{children:["\n",(0,r.jsx)(n.li,{children:"Pencil stroke preview before commit"}),"\n",(0,r.jsx)(n.li,{children:"Transform handle positions"}),"\n",(0,r.jsx)(n.li,{children:"Text cursor position"}),"\n"]}),"\n"]}),"\n",(0,r.jsxs)(n.li,{children:["\n",(0,r.jsxs)(n.p,{children:[(0,r.jsx)(n.strong,{children:"Panel visibility"}),": UI panel open/closed states"]}),"\n",(0,r.jsxs)(n.ul,{children:["\n",(0,r.jsx)(n.li,{children:"Sidebar expansion"}),"\n",(0,r.jsx)(n.li,{children:"Panel toggles"}),"\n",(0,r.jsx)(n.li,{children:"Theme preferences"}),"\n"]}),"\n"]}),"\n"]}),"\n",(0,r.jsxs)(n.p,{children:[(0,r.jsx)(n.strong,{children:"Rationale:"})," Excluding non-essential state prevents history pollution and keeps snapshots focused on meaningful canvas changes."]}),"\n",(0,r.jsx)(n.h2,{id:"undoredo-flow",children:"Undo/Redo Flow"}),"\n",(0,r.jsx)(n.mermaid,{value:"sequenceDiagram\n    participant User\n    participant UI\n    participant Store\n    participant Zundo as Zundo Middleware\n    participant History as History Stack\n    \n    User->>UI: Perform action (e.g., move element)\n    UI->>Store: set({ elements: newElements })\n    Store->>Zundo: State changed\n    \n    Zundo->>Zundo: Check cooldown (100ms)\n    alt Cooldown expired\n        Zundo->>History: Push snapshot to past[]\n        Zundo->>History: Clear future[]\n        Note over History: pastStates.length++<br/>futureStates = []\n    else Within cooldown\n        Zundo->>Zundo: Skip snapshot\n        Note over Zundo: Debounced action ignored\n    end\n    \n    User->>UI: Press Ctrl+Z (Undo)\n    UI->>Zundo: temporal.undo()\n    Zundo->>History: Pop from past[]\n    Zundo->>History: Push current to future[]\n    Zundo->>Store: Restore previous state\n    Store->>UI: Re-render with old state\n    Note over UI: Elements restored<br/>Selection restored<br/>Viewport restored\n    \n    User->>UI: Press Ctrl+Shift+Z (Redo)\n    UI->>Zundo: temporal.redo()\n    Zundo->>History: Pop from future[]\n    Zundo->>History: Push current to past[]\n    Zundo->>Store: Restore next state\n    Store->>UI: Re-render with restored state\n    Note over UI: Forward in history"}),"\n",(0,r.jsx)(n.h2,{id:"usage",children:"Usage"}),"\n",(0,r.jsx)(n.h3,{id:"keyboard-shortcuts",children:"Keyboard Shortcuts"}),"\n",(0,r.jsx)(n.p,{children:"The system provides standard keyboard shortcuts for undo/redo:"}),"\n",(0,r.jsxs)(n.ul,{children:["\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.strong,{children:"Undo"}),": ",(0,r.jsx)(n.code,{children:"Ctrl + Z"})," (Windows/Linux) or ",(0,r.jsx)(n.code,{children:"Cmd + Z"})," (macOS)"]}),"\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.strong,{children:"Redo"}),": ",(0,r.jsx)(n.code,{children:"Ctrl + Shift + Z"})," (Windows/Linux) or ",(0,r.jsx)(n.code,{children:"Cmd + Shift + Z"})," (macOS)"]}),"\n"]}),"\n",(0,r.jsxs)(n.p,{children:[(0,r.jsx)(n.strong,{children:"Implementation:"})," Handled by ",(0,r.jsx)(n.code,{children:"useKeyboardShortcuts"})," hook which dispatches to ",(0,r.jsx)(n.code,{children:"temporal.undo()"})," and ",(0,r.jsx)(n.code,{children:"temporal.redo()"}),"."]}),"\n",(0,r.jsx)(n.h3,{id:"ui-controls",children:"UI Controls"}),"\n",(0,r.jsxs)(n.p,{children:["Undo/redo buttons are displayed in the ",(0,r.jsx)(n.strong,{children:"Bottom Action Bar"})," with visual counters:"]}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-tsx",children:"// In BottomActionBar.tsx\n<ToolbarIconButton\n  icon={Undo2}\n  label=\"Undo\"\n  onClick={() => undo()}\n  isDisabled={!canUndo || activePlugin === 'curves'}\n  counter={pastStates.length} // Shows number of available undos\n/>\n\n<ToolbarIconButton\n  icon={Redo2}\n  label=\"Redo\"\n  onClick={() => redo()}\n  isDisabled={!canRedo || activePlugin === 'curves'}\n  counter={futureStates.length} // Shows number of available redos\n/>\n"})}),"\n",(0,r.jsx)(n.p,{children:(0,r.jsx)(n.strong,{children:"Button states:"})}),"\n",(0,r.jsxs)(n.ul,{children:["\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.strong,{children:"Enabled"}),": When ",(0,r.jsx)(n.code,{children:"pastStates.length > 0"})," (undo) or ",(0,r.jsx)(n.code,{children:"futureStates.length > 0"})," (redo)"]}),"\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.strong,{children:"Disabled"}),": When no history available or in incompatible plugin (e.g., curves)"]}),"\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.strong,{children:"Counter badge"}),": Shows number of available undo/redo steps"]}),"\n"]}),"\n",(0,r.jsx)(n.h2,{id:"api-reference",children:"API Reference"}),"\n",(0,r.jsx)(n.h3,{id:"accessing-temporal-state",children:"Accessing Temporal State"}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-typescript",children:"import { useCanvasStore } from './store/canvasStore';\n\n// Access temporal state via the temporal property\nconst { undo, redo, clear, pastStates, futureStates } = useCanvasStore.temporal.getState();\n"})}),"\n",(0,r.jsx)(n.h3,{id:"temporal-methods",children:"Temporal Methods"}),"\n",(0,r.jsx)(n.h4,{id:"undo",children:(0,r.jsx)(n.code,{children:"undo()"})}),"\n",(0,r.jsx)(n.p,{children:"Undoes the last action by restoring the previous state from history."}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-typescript",children:"const { undo } = useCanvasStore.temporal.getState();\nundo();\n"})}),"\n",(0,r.jsx)(n.p,{children:(0,r.jsx)(n.strong,{children:"Behavior:"})}),"\n",(0,r.jsxs)(n.ul,{children:["\n",(0,r.jsxs)(n.li,{children:["Pops most recent snapshot from ",(0,r.jsx)(n.code,{children:"pastStates[]"})]}),"\n",(0,r.jsxs)(n.li,{children:["Pushes current state to ",(0,r.jsx)(n.code,{children:"futureStates[]"})]}),"\n",(0,r.jsx)(n.li,{children:"Restores elements, selection, viewport from snapshot"}),"\n",(0,r.jsxs)(n.li,{children:["No effect if ",(0,r.jsx)(n.code,{children:"pastStates"})," is empty"]}),"\n"]}),"\n",(0,r.jsx)(n.h4,{id:"redo",children:(0,r.jsx)(n.code,{children:"redo()"})}),"\n",(0,r.jsx)(n.p,{children:"Redoes a previously undone action by restoring the next state from future history."}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-typescript",children:"const { redo } = useCanvasStore.temporal.getState();\nredo();\n"})}),"\n",(0,r.jsx)(n.p,{children:(0,r.jsx)(n.strong,{children:"Behavior:"})}),"\n",(0,r.jsxs)(n.ul,{children:["\n",(0,r.jsxs)(n.li,{children:["Pops most recent snapshot from ",(0,r.jsx)(n.code,{children:"futureStates[]"})]}),"\n",(0,r.jsxs)(n.li,{children:["Pushes current state to ",(0,r.jsx)(n.code,{children:"pastStates[]"})]}),"\n",(0,r.jsx)(n.li,{children:"Restores elements, selection, viewport from snapshot"}),"\n",(0,r.jsxs)(n.li,{children:["No effect if ",(0,r.jsx)(n.code,{children:"futureStates"})," is empty"]}),"\n"]}),"\n",(0,r.jsx)(n.h4,{id:"clear",children:(0,r.jsx)(n.code,{children:"clear()"})}),"\n",(0,r.jsx)(n.p,{children:"Clears all undo/redo history, resetting the history stacks to empty."}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-typescript",children:"const { clear } = useCanvasStore.temporal.getState();\nclear();\n"})}),"\n",(0,r.jsx)(n.p,{children:(0,r.jsx)(n.strong,{children:"Use cases:"})}),"\n",(0,r.jsxs)(n.ul,{children:["\n",(0,r.jsx)(n.li,{children:"After loading a new document"}),"\n",(0,r.jsx)(n.li,{children:'On explicit "Clear History" action'}),"\n",(0,r.jsx)(n.li,{children:"When entering a mode that doesn't support undo (e.g., non-destructive preview)"}),"\n"]}),"\n",(0,r.jsxs)(n.p,{children:[(0,r.jsx)(n.strong,{children:"Warning:"})," This operation is irreversible; past history cannot be recovered."]}),"\n",(0,r.jsx)(n.h3,{id:"temporal-state-properties",children:"Temporal State Properties"}),"\n",(0,r.jsx)(n.h4,{id:"paststates",children:(0,r.jsx)(n.code,{children:"pastStates"})}),"\n",(0,r.jsx)(n.p,{children:"Array of previous state snapshots available for undo."}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-typescript",children:"const { pastStates } = useCanvasStore.temporal.getState();\nconsole.log(`Can undo ${pastStates.length} steps`);\n"})}),"\n",(0,r.jsxs)(n.p,{children:[(0,r.jsx)(n.strong,{children:"Type:"})," ",(0,r.jsx)(n.code,{children:"Array<Partial<CanvasStore>>"})]}),"\n",(0,r.jsxs)(n.p,{children:[(0,r.jsx)(n.strong,{children:"Max length:"})," 50 (oldest entries removed when limit exceeded)"]}),"\n",(0,r.jsx)(n.h4,{id:"futurestates",children:(0,r.jsx)(n.code,{children:"futureStates"})}),"\n",(0,r.jsx)(n.p,{children:"Array of future state snapshots available for redo (populated after undo)."}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-typescript",children:"const { futureStates } = useCanvasStore.temporal.getState();\nconsole.log(`Can redo ${futureStates.length} steps`);\n"})}),"\n",(0,r.jsxs)(n.p,{children:[(0,r.jsx)(n.strong,{children:"Type:"})," ",(0,r.jsx)(n.code,{children:"Array<Partial<CanvasStore>>"})]}),"\n",(0,r.jsxs)(n.p,{children:[(0,r.jsx)(n.strong,{children:"Behavior:"})," Cleared when a new action is performed (branching from past state)"]}),"\n",(0,r.jsx)(n.h2,{id:"usage-examples",children:"Usage Examples"}),"\n",(0,r.jsx)(n.h3,{id:"basic-undoredo",children:"Basic Undo/Redo"}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-typescript",children:"// Perform some actions\nstate.addElement(newElement);\nstate.updateElement('element-1', { x: 100 });\nstate.deleteElement('element-2');\n\n// Undo last action (deletion)\nuseCanvasStore.temporal.getState().undo();\n\n// Redo the undone action\nuseCanvasStore.temporal.getState().redo();\n"})}),"\n",(0,r.jsx)(n.h3,{id:"check-history-availability",children:"Check History Availability"}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-typescript",children:"const { pastStates, futureStates } = useCanvasStore.temporal.getState();\n\nif (pastStates.length > 0) {\n  console.log(`Can undo ${pastStates.length} steps`);\n  // Enable undo button\n}\n\nif (futureStates.length > 0) {\n  console.log(`Can redo ${futureStates.length} steps`);\n  // Enable redo button\n}\n"})}),"\n",(0,r.jsx)(n.h3,{id:"clear-history-on-document-load",children:"Clear History on Document Load"}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-typescript",children:"const loadDocument = async (file: File) => {\n  // Parse document\n  const documentData = await parseDocumentFile(file);\n  \n  // Load elements into store\n  useCanvasStore.setState({ elements: documentData.elements });\n  \n  // Clear undo history (new document context)\n  useCanvasStore.temporal.getState().clear();\n};\n"})}),"\n",(0,r.jsx)(n.h3,{id:"custom-undo-hook",children:"Custom Undo Hook"}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-typescript",children:"import { useEffect, useState } from 'react';\nimport { useCanvasStore } from './store/canvasStore';\n\nconst useTemporalState = () => {\n  const [temporalState, setTemporalState] = useState(() => \n    useCanvasStore.temporal.getState()\n  );\n\n  useEffect(() => {\n    const unsubscribe = useCanvasStore.temporal.subscribe(setTemporalState);\n    return unsubscribe;\n  }, []);\n\n  return temporalState;\n};\n\n// Usage in component\nconst MyComponent = () => {\n  const { undo, redo, pastStates, futureStates } = useTemporalState();\n  \n  return (\n    <div>\n      <button onClick={undo} disabled={pastStates.length === 0}>\n        Undo ({pastStates.length})\n      </button>\n      <button onClick={redo} disabled={futureStates.length === 0}>\n        Redo ({futureStates.length})\n      </button>\n    </div>\n  );\n};\n"})}),"\n",(0,r.jsx)(n.h2,{id:"cooldown-period-explained",children:"Cooldown Period Explained"}),"\n",(0,r.jsxs)(n.p,{children:["The ",(0,r.jsx)(n.strong,{children:"100ms cooldown"})," prevents excessive snapshot creation during rapid, continuous actions like dragging or drawing. Without cooldown, every mousemove event would create a snapshot, quickly filling the 50-entry history limit with redundant states."]}),"\n",(0,r.jsx)(n.p,{children:(0,r.jsx)(n.strong,{children:"How it works:"})}),"\n",(0,r.jsxs)(n.ol,{children:["\n",(0,r.jsx)(n.li,{children:"User starts dragging an element (first state change triggers snapshot)"}),"\n",(0,r.jsx)(n.li,{children:"During drag, state updates occur every ~16ms (60fps)"}),"\n",(0,r.jsx)(n.li,{children:"Cooldown debouncer ignores updates within 100ms window"}),"\n",(0,r.jsx)(n.li,{children:"Only after 100ms of inactivity does next snapshot get created"}),"\n",(0,r.jsx)(n.li,{children:"When drag ends, final state is captured"}),"\n"]}),"\n",(0,r.jsx)(n.p,{children:(0,r.jsx)(n.strong,{children:"Example timeline:"})}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{children:"Time (ms): 0    50   100  150  200  250  300\nAction:    Drag \u2192  \u2192   \u2192    \u2192    \u2192    End\nSnapshot:  \u2713    \u2717   \u2717    \u2717    \u2717    \u2713\n"})}),"\n",(0,r.jsx)(n.p,{children:(0,r.jsx)(n.strong,{children:"Benefits:"})}),"\n",(0,r.jsxs)(n.ul,{children:["\n",(0,r.jsx)(n.li,{children:"Prevents history pollution from continuous actions"}),"\n",(0,r.jsx)(n.li,{children:"Maintains meaningful undo steps (start/end of operation)"}),"\n",(0,r.jsx)(n.li,{children:"Reduces memory usage and improves performance"}),"\n",(0,r.jsx)(n.li,{children:"Users experience logical undo behavior (undo entire drag, not individual mousemove)"}),"\n"]}),"\n",(0,r.jsx)(n.h2,{id:"best-practices",children:"Best Practices"}),"\n",(0,r.jsx)(n.h3,{id:"for-users",children:"For Users"}),"\n",(0,r.jsxs)(n.ul,{children:["\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.strong,{children:"Undo frequently"}),": Don't hesitate to undo and explore alternative approaches"]}),"\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.strong,{children:"Use redo"}),": After undoing, you can redo to compare options"]}),"\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.strong,{children:"Mind the limit"}),": Only last 50 actions are retained; older history is lost"]}),"\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.strong,{children:"Save before risky operations"}),": Complex edits may consume multiple undo steps"]}),"\n"]}),"\n",(0,r.jsx)(n.h3,{id:"for-plugin-developers",children:"For Plugin Developers"}),"\n",(0,r.jsxs)(n.ul,{children:["\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.strong,{children:"Let system handle snapshots"}),": Don't manually call snapshot creation; system handles it automatically"]}),"\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.strong,{children:"Batch operations"}),": Group related state changes in single ",(0,r.jsx)(n.code,{children:"set()"})," call to create one snapshot"]}),"\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.strong,{children:"Respect partialize"}),": Only modify tracked state fields (",(0,r.jsx)(n.code,{children:"elements"}),", ",(0,r.jsx)(n.code,{children:"selectedIds"}),", ",(0,r.jsx)(n.code,{children:"viewport"}),")"]}),"\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.strong,{children:"Don't mutate state"}),": Always return new objects; Zustand relies on immutability"]}),"\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.strong,{children:"Test undo behavior"}),": Verify that undoing your operation restores expected state"]}),"\n"]}),"\n",(0,r.jsx)(n.h2,{id:"limitations",children:"Limitations"}),"\n",(0,r.jsxs)(n.ul,{children:["\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.strong,{children:"50-step limit"}),": Only last 50 actions are retained"]}),"\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.strong,{children:"No branching"}),": Performing a new action after undo clears redo history (linear timeline)"]}),"\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.strong,{children:"Memory overhead"}),": Each snapshot stores complete element/selection/viewport state"]}),"\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.strong,{children:"Cooldown delays"}),": Very rapid actions (< 100ms apart) may not create individual snapshots"]}),"\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.strong,{children:"No partial undo"}),": Can't undo individual property changes; entire snapshot is restored"]}),"\n"]}),"\n",(0,r.jsx)(n.h2,{id:"related-documentation",children:"Related Documentation"}),"\n",(0,r.jsxs)(n.ul,{children:["\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.a,{href:"../api/canvas-store",children:"Canvas Store"})," - Store architecture and slices"]}),"\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.a,{href:"/ttpe/docs/architecture/overview#state-management-strategy",children:"State Management"})," - Zustand + Zundo integration"]}),"\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.a,{href:"/ttpe/docs/features/persistence",children:"Persistence"})," - localStorage persistence (undo history not saved)"]}),"\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.a,{href:"/ttpe/docs/app-structure/actionbars",children:"Action Bars"})," - Undo/redo UI controls"]}),"\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.a,{href:"/ttpe/docs/event-bus/topics",children:"Event Bus"})," - Keyboard event handling for shortcuts"]}),"\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.a,{href:"https://github.com/charkour/zundo",children:"Zundo Documentation"})," - Official Zundo middleware docs"]}),"\n"]})]})}function h(e={}){const{wrapper:n}={...(0,o.R)(),...e.components};return n?(0,r.jsx)(n,{...e,children:(0,r.jsx)(c,{...e})}):c(e)}},8453:(e,n,t)=>{t.d(n,{R:()=>i,x:()=>a});var s=t(6540);const r={},o=s.createContext(r);function i(e){const n=s.useContext(o);return s.useMemo(function(){return"function"==typeof e?e(n):{...n,...e}},[n,e])}function a(e){let n;return n=e.disableParentContext?"function"==typeof e.components?e.components(r):e.components||r:i(e.components),s.createElement(o.Provider,{value:n},e.children)}}}]);