"use strict";(self.webpackChunkttpe_docs=self.webpackChunkttpe_docs||[]).push([[2574],{3376:(e,n,t)=>{t.r(n),t.d(n,{assets:()=>o,contentTitle:()=>l,default:()=>p,frontMatter:()=>r,metadata:()=>i,toc:()=>d});const i=JSON.parse('{"id":"event-bus/patterns","title":"Event Patterns","description":"Advanced patterns and best practices for working with TTPE\'s Event Bus. This guide covers common scenarios, performance optimizations, error handling, and architectural patterns used throughout the codebase.","source":"@site/docs/event-bus/patterns.md","sourceDirName":"event-bus","slug":"/event-bus/patterns","permalink":"/ttpe/docs/event-bus/patterns","draft":false,"unlisted":false,"editUrl":"https://github.com/ekrsulov/ttpe/tree/main/doc/docs/event-bus/patterns.md","tags":[],"version":"current","lastUpdatedBy":"Ernesto Krsulovic","lastUpdatedAt":1762144179000,"frontMatter":{"id":"patterns","title":"Event Patterns","sidebar_label":"Patterns"},"sidebar":"docs","previous":{"title":"Topics","permalink":"/ttpe/docs/event-bus/topics"},"next":{"title":"createApi","permalink":"/ttpe/docs/api/create-api"}}');var a=t(4848),s=t(8453);const r={id:"patterns",title:"Event Patterns",sidebar_label:"Patterns"},l="Event Patterns",o={},d=[{value:"Core Patterns",id:"core-patterns",level:2},{value:"1. Plugin-Scoped Handlers",id:"1-plugin-scoped-handlers",level:3},{value:"2. Multi-Phase Event Handling",id:"2-multi-phase-event-handling",level:3},{value:"3. Conditional Behavior Based on Modifiers",id:"3-conditional-behavior-based-on-modifiers",level:3},{value:"4. State-Dependent Handlers",id:"4-state-dependent-handlers",level:3},{value:"5. Debounced Event Handlers",id:"5-debounced-event-handlers",level:3},{value:"Error Handling Patterns",id:"error-handling-patterns",level:2},{value:"Graceful Degradation",id:"graceful-degradation",level:3},{value:"Validation Pattern",id:"validation-pattern",level:3},{value:"Defensive State Access",id:"defensive-state-access",level:3},{value:"Performance Patterns",id:"performance-patterns",level:2},{value:"Early Exit Optimization",id:"early-exit-optimization",level:3},{value:"Throttled Processing",id:"throttled-processing",level:3},{value:"Batch Updates",id:"batch-updates",level:3},{value:"React Integration Patterns",id:"react-integration-patterns",level:2},{value:"Hook-Based Subscription",id:"hook-based-subscription",level:3},{value:"State Synchronization",id:"state-synchronization",level:3},{value:"Callback Dependencies",id:"callback-dependencies",level:3},{value:"Advanced Patterns",id:"advanced-patterns",level:2},{value:"Event Filtering Pipeline",id:"event-filtering-pipeline",level:3},{value:"Event Composition",id:"event-composition",level:3},{value:"Cross-Plugin Communication",id:"cross-plugin-communication",level:3},{value:"Testing Patterns",id:"testing-patterns",level:2},{value:"Mock Event Bus",id:"mock-event-bus",level:3},{value:"Simulate Events",id:"simulate-events",level:3},{value:"Anti-Patterns to Avoid",id:"anti-patterns-to-avoid",level:2},{value:"\u274c Forgetting to Unsubscribe",id:"-forgetting-to-unsubscribe",level:3},{value:"\u274c Mutating Payload",id:"-mutating-payload",level:3},{value:"\u274c Heavy Computation in Handlers",id:"-heavy-computation-in-handlers",level:3},{value:"\u274c Circular Event Emissions",id:"-circular-event-emissions",level:3},{value:"Pattern Summary",id:"pattern-summary",level:2},{value:"Related Documentation",id:"related-documentation",level:2}];function c(e){const n={a:"a",code:"code",h1:"h1",h2:"h2",h3:"h3",header:"header",li:"li",mermaid:"mermaid",p:"p",pre:"pre",strong:"strong",table:"table",tbody:"tbody",td:"td",th:"th",thead:"thead",tr:"tr",ul:"ul",...(0,s.R)(),...e.components};return(0,a.jsxs)(a.Fragment,{children:[(0,a.jsx)(n.header,{children:(0,a.jsx)(n.h1,{id:"event-patterns",children:"Event Patterns"})}),"\n",(0,a.jsx)(n.p,{children:"Advanced patterns and best practices for working with TTPE's Event Bus. This guide covers common scenarios, performance optimizations, error handling, and architectural patterns used throughout the codebase."}),"\n",(0,a.jsx)(n.h2,{id:"core-patterns",children:"Core Patterns"}),"\n",(0,a.jsx)(n.h3,{id:"1-plugin-scoped-handlers",children:"1. Plugin-Scoped Handlers"}),"\n",(0,a.jsx)(n.p,{children:"The most common pattern: plugins only respond to events when they're active."}),"\n",(0,a.jsx)(n.pre,{children:(0,a.jsx)(n.code,{className:"language-typescript",children:"eventBus.subscribe('pointerdown', (payload) => {\n  // Early exit if this plugin isn't active\n  if (payload.activePlugin !== 'my-plugin') return;\n  \n  // Plugin-specific handling\n  const { point, event } = payload;\n  handlePointerDown(point, event.shiftKey);\n});\n"})}),"\n",(0,a.jsxs)(n.p,{children:[(0,a.jsx)(n.strong,{children:"Why"}),": Prevents unnecessary processing and avoids conflicts between plugins."]}),"\n",(0,a.jsxs)(n.p,{children:[(0,a.jsx)(n.strong,{children:"Visual Flow"}),":"]}),"\n",(0,a.jsx)(n.mermaid,{value:"graph TD\n    A[Event emitted] --\x3e B{Check activePlugin}\n    B --\x3e|Match| C[Execute handler logic]\n    B --\x3e|No match| D[Return early - no-op]\n    \n    style B fill:#fff4e1\n    style C fill:#c8e6c9\n    style D fill:#ffcdd2"}),"\n",(0,a.jsx)(n.h3,{id:"2-multi-phase-event-handling",children:"2. Multi-Phase Event Handling"}),"\n",(0,a.jsx)(n.p,{children:"Complex interactions often span multiple event types:"}),"\n",(0,a.jsx)(n.pre,{children:(0,a.jsx)(n.code,{className:"language-typescript",children:"let isDragging = false;\nlet startPoint: Point | null = null;\n\n// Phase 1: Start\neventBus.subscribe('pointerdown', (payload) => {\n  if (payload.activePlugin !== 'select') return;\n  \n  isDragging = true;\n  startPoint = payload.point;\n});\n\n// Phase 2: Update\neventBus.subscribe('pointermove', (payload) => {\n  if (!isDragging || payload.activePlugin !== 'select') return;\n  \n  const currentPoint = payload.point;\n  updateSelectionRectangle(startPoint, currentPoint);\n});\n\n// Phase 3: Complete\neventBus.subscribe('pointerup', (payload) => {\n  if (!isDragging || payload.activePlugin !== 'select') return;\n  \n  finalizeSelection(startPoint, payload.point);\n  isDragging = false;\n  startPoint = null;\n});\n"})}),"\n",(0,a.jsxs)(n.p,{children:[(0,a.jsx)(n.strong,{children:"Lifecycle Diagram"}),":"]}),"\n",(0,a.jsx)(n.mermaid,{value:"stateDiagram-v2\n    [*] --\x3e Idle\n    Idle --\x3e Dragging: pointerdown\n    Dragging --\x3e Dragging: pointermove\n    Dragging --\x3e Idle: pointerup\n    \n    note right of Idle\n        isDragging = false\n        startPoint = null\n    end note\n    \n    note right of Dragging\n        isDragging = true\n        startPoint = {x, y}\n    end note"}),"\n",(0,a.jsx)(n.h3,{id:"3-conditional-behavior-based-on-modifiers",children:"3. Conditional Behavior Based on Modifiers"}),"\n",(0,a.jsx)(n.p,{children:"Use modifier keys to enable different behaviors:"}),"\n",(0,a.jsx)(n.pre,{children:(0,a.jsx)(n.code,{className:"language-typescript",children:"eventBus.subscribe('pointerdown', (payload) => {\n  if (payload.activePlugin !== 'select') return;\n  \n  const { event, point } = payload;\n  const state = useCanvasStore.getState();\n  \n  if (event.shiftKey) {\n    // Add to existing selection\n    state.addToSelection(getElementAt(point));\n  } else if (event.ctrlKey || event.metaKey) {\n    // Toggle selection\n    state.toggleSelection(getElementAt(point));\n  } else {\n    // Replace selection\n    state.setSelection([getElementAt(point)]);\n  }\n});\n"})}),"\n",(0,a.jsxs)(n.p,{children:[(0,a.jsx)(n.strong,{children:"Decision Tree"}),":"]}),"\n",(0,a.jsx)(n.mermaid,{value:"graph TD\n    A[pointerdown event] --\x3e B{Shift key?}\n    B --\x3e|Yes| C[Add to selection]\n    B --\x3e|No| D{Ctrl/Cmd key?}\n    D --\x3e|Yes| E[Toggle selection]\n    D --\x3e|No| F[Replace selection]\n    \n    style C fill:#c8e6c9\n    style E fill:#fff59d\n    style F fill:#b3e5fc"}),"\n",(0,a.jsx)(n.h3,{id:"4-state-dependent-handlers",children:"4. State-Dependent Handlers"}),"\n",(0,a.jsx)(n.p,{children:"Behavior changes based on current state:"}),"\n",(0,a.jsx)(n.pre,{children:(0,a.jsx)(n.code,{className:"language-typescript",children:"eventBus.subscribe('pointerdown', (payload) => {\n  if (payload.activePlugin !== 'pencil') return;\n  \n  const state = useCanvasStore.getState();\n  const { currentPath } = state.pencil;\n  \n  if (currentPath) {\n    // Continue existing path\n    addPointToPath(currentPath, payload.point);\n  } else {\n    // Start new path\n    startNewPath(payload.point);\n  }\n});\n"})}),"\n",(0,a.jsx)(n.h3,{id:"5-debounced-event-handlers",children:"5. Debounced Event Handlers"}),"\n",(0,a.jsx)(n.p,{children:"Limit processing frequency for performance:"}),"\n",(0,a.jsx)(n.pre,{children:(0,a.jsx)(n.code,{className:"language-typescript",children:"import { debounce } from 'lodash';\n\nconst debouncedHandler = debounce((payload: CanvasPointerEventPayload) => {\n  // Expensive operation (e.g., auto-save)\n  saveCanvasState();\n}, 500);\n\neventBus.subscribe('pointermove', (payload) => {\n  if (payload.activePlugin !== 'pencil') return;\n  \n  // Immediate: Update drawing\n  updatePath(payload.point);\n  \n  // Debounced: Save state\n  debouncedHandler(payload);\n});\n"})}),"\n",(0,a.jsx)(n.h2,{id:"error-handling-patterns",children:"Error Handling Patterns"}),"\n",(0,a.jsx)(n.h3,{id:"graceful-degradation",children:"Graceful Degradation"}),"\n",(0,a.jsx)(n.p,{children:"Always handle errors gracefully to prevent crashing other plugins:"}),"\n",(0,a.jsx)(n.pre,{children:(0,a.jsx)(n.code,{className:"language-typescript",children:"eventBus.subscribe('pointerdown', (payload) => {\n  try {\n    if (payload.activePlugin !== 'my-plugin') return;\n    \n    // Potentially risky operations\n    const element = findElementAt(payload.point);\n    processElement(element);\n    \n  } catch (error) {\n    console.error('[MyPlugin] Error handling pointerdown:', error);\n    \n    // Optionally show user feedback\n    showToast('An error occurred. Please try again.');\n    \n    // Reset plugin state\n    resetPluginState();\n  }\n});\n"})}),"\n",(0,a.jsx)(n.h3,{id:"validation-pattern",children:"Validation Pattern"}),"\n",(0,a.jsx)(n.p,{children:"Validate payload data before processing:"}),"\n",(0,a.jsx)(n.pre,{children:(0,a.jsx)(n.code,{className:"language-typescript",children:"eventBus.subscribe('pointerdown', (payload) => {\n  if (payload.activePlugin !== 'my-plugin') return;\n  \n  // Validate payload\n  if (!payload.point || typeof payload.point.x !== 'number') {\n    console.warn('[MyPlugin] Invalid point in payload');\n    return;\n  }\n  \n  if (!payload.event) {\n    console.warn('[MyPlugin] Missing event in payload');\n    return;\n  }\n  \n  // Safe to proceed\n  handlePointerDown(payload);\n});\n"})}),"\n",(0,a.jsx)(n.h3,{id:"defensive-state-access",children:"Defensive State Access"}),"\n",(0,a.jsx)(n.p,{children:"Check store state before using it:"}),"\n",(0,a.jsx)(n.pre,{children:(0,a.jsx)(n.code,{className:"language-typescript",children:"eventBus.subscribe('pointerdown', (payload) => {\n  if (payload.activePlugin !== 'edit') return;\n  \n  const state = useCanvasStore.getState();\n  const selectedElement = state.elements.find(\n    el => el.id === state.selectedIds[0]\n  );\n  \n  if (!selectedElement) {\n    console.warn('[EditPlugin] No selected element found');\n    return;\n  }\n  \n  if (selectedElement.type !== 'path') {\n    console.warn('[EditPlugin] Selected element is not a path');\n    return;\n  }\n  \n  // Safe to edit path\n  editPath(selectedElement, payload.point);\n});\n"})}),"\n",(0,a.jsx)(n.h2,{id:"performance-patterns",children:"Performance Patterns"}),"\n",(0,a.jsx)(n.h3,{id:"early-exit-optimization",children:"Early Exit Optimization"}),"\n",(0,a.jsx)(n.p,{children:"Exit as early as possible to avoid unnecessary work:"}),"\n",(0,a.jsx)(n.pre,{children:(0,a.jsx)(n.code,{className:"language-typescript",children:"eventBus.subscribe('pointermove', (payload) => {\n  // Exit #1: Wrong plugin\n  if (payload.activePlugin !== 'pencil') return;\n  \n  const state = useCanvasStore.getState();\n  \n  // Exit #2: Not drawing\n  if (!state.pencil.isDrawing) return;\n  \n  // Exit #3: No current path\n  if (!state.pencil.currentPath) return;\n  \n  // Exit #4: Point too close to last point\n  const lastPoint = getLastPoint(state.pencil.currentPath);\n  if (distance(lastPoint, payload.point) < 2) return;\n  \n  // Now perform expensive operation\n  updatePathWithSmoothing(payload.point);\n});\n"})}),"\n",(0,a.jsx)(n.h3,{id:"throttled-processing",children:"Throttled Processing"}),"\n",(0,a.jsx)(n.p,{children:"Limit processing rate for expensive operations:"}),"\n",(0,a.jsx)(n.pre,{children:(0,a.jsx)(n.code,{className:"language-typescript",children:"let lastProcessTime = 0;\nconst THROTTLE_MS = 16; // ~60fps\n\neventBus.subscribe('pointermove', (payload) => {\n  if (payload.activePlugin !== 'my-plugin') return;\n  \n  const now = Date.now();\n  if (now - lastProcessTime < THROTTLE_MS) return;\n  \n  lastProcessTime = now;\n  expensiveOperation(payload.point);\n});\n"})}),"\n",(0,a.jsx)(n.h3,{id:"batch-updates",children:"Batch Updates"}),"\n",(0,a.jsx)(n.p,{children:"Collect multiple events and process them together:"}),"\n",(0,a.jsx)(n.pre,{children:(0,a.jsx)(n.code,{className:"language-typescript",children:"let pendingPoints: Point[] = [];\nlet batchTimeout: number | null = null;\n\neventBus.subscribe('pointermove', (payload) => {\n  if (payload.activePlugin !== 'pencil') return;\n  \n  // Add point to batch\n  pendingPoints.push(payload.point);\n  \n  // Clear existing timeout\n  if (batchTimeout) clearTimeout(batchTimeout);\n  \n  // Schedule batch processing\n  batchTimeout = setTimeout(() => {\n    processBatch(pendingPoints);\n    pendingPoints = [];\n    batchTimeout = null;\n  }, 50);\n});\n"})}),"\n",(0,a.jsx)(n.h2,{id:"react-integration-patterns",children:"React Integration Patterns"}),"\n",(0,a.jsx)(n.h3,{id:"hook-based-subscription",children:"Hook-Based Subscription"}),"\n",(0,a.jsx)(n.pre,{children:(0,a.jsx)(n.code,{className:"language-typescript",children:"import { useEffect } from 'react';\nimport { eventBus } from '@/canvas/eventBus';\n\nfunction useCanvasEvents(pluginId: string) {\n  useEffect(() => {\n    const unsubPointerDown = eventBus.subscribe('pointerdown', (payload) => {\n      if (payload.activePlugin !== pluginId) return;\n      handlePointerDown(payload);\n    });\n    \n    const unsubPointerMove = eventBus.subscribe('pointermove', (payload) => {\n      if (payload.activePlugin !== pluginId) return;\n      handlePointerMove(payload);\n    });\n    \n    const unsubPointerUp = eventBus.subscribe('pointerup', (payload) => {\n      if (payload.activePlugin !== pluginId) return;\n      handlePointerUp(payload);\n    });\n    \n    // Cleanup all subscriptions\n    return () => {\n      unsubPointerDown();\n      unsubPointerMove();\n      unsubPointerUp();\n    };\n  }, [pluginId]); // Re-subscribe if plugin ID changes\n}\n"})}),"\n",(0,a.jsx)(n.h3,{id:"state-synchronization",children:"State Synchronization"}),"\n",(0,a.jsx)(n.p,{children:"Sync event data with component state:"}),"\n",(0,a.jsx)(n.pre,{children:(0,a.jsx)(n.code,{className:"language-typescript",children:"function MyPlugin() {\n  const [currentPoint, setCurrentPoint] = useState<Point | null>(null);\n  const [isDragging, setIsDragging] = useState(false);\n  \n  useEffect(() => {\n    const unsubDown = eventBus.subscribe('pointerdown', (payload) => {\n      if (payload.activePlugin !== 'my-plugin') return;\n      setIsDragging(true);\n      setCurrentPoint(payload.point);\n    });\n    \n    const unsubMove = eventBus.subscribe('pointermove', (payload) => {\n      if (!isDragging || payload.activePlugin !== 'my-plugin') return;\n      setCurrentPoint(payload.point);\n    });\n    \n    const unsubUp = eventBus.subscribe('pointerup', () => {\n      setIsDragging(false);\n      setCurrentPoint(null);\n    });\n    \n    return () => {\n      unsubDown();\n      unsubMove();\n      unsubUp();\n    };\n  }, [isDragging]);\n  \n  return (\n    <div>\n      {isDragging && currentPoint && (\n        <Cursor x={currentPoint.x} y={currentPoint.y} />\n      )}\n    </div>\n  );\n}\n"})}),"\n",(0,a.jsx)(n.h3,{id:"callback-dependencies",children:"Callback Dependencies"}),"\n",(0,a.jsx)(n.p,{children:"Handle dependencies correctly in event handlers:"}),"\n",(0,a.jsx)(n.pre,{children:(0,a.jsx)(n.code,{className:"language-typescript",children:"function MyPlugin({ onUpdate }: { onUpdate: (point: Point) => void }) {\n  const activePlugin = useCanvasStore(state => state.activePlugin);\n  \n  useEffect(() => {\n    const unsubscribe = eventBus.subscribe('pointermove', (payload) => {\n      if (payload.activePlugin !== 'my-plugin') return;\n      \n      // onUpdate is a dependency - handler will update when it changes\n      onUpdate(payload.point);\n    });\n    \n    return unsubscribe;\n  }, [onUpdate]); // Re-subscribe when onUpdate changes\n}\n"})}),"\n",(0,a.jsx)(n.h2,{id:"advanced-patterns",children:"Advanced Patterns"}),"\n",(0,a.jsx)(n.h3,{id:"event-filtering-pipeline",children:"Event Filtering Pipeline"}),"\n",(0,a.jsx)(n.p,{children:"Create reusable filters:"}),"\n",(0,a.jsx)(n.pre,{children:(0,a.jsx)(n.code,{className:"language-typescript",children:"// Filter factory\nconst createPluginFilter = (pluginId: string) => \n  (payload: CanvasPointerEventPayload) => \n    payload.activePlugin === pluginId;\n\nconst createModifierFilter = (modifiers: { shift?: boolean; ctrl?: boolean }) =>\n  (payload: CanvasPointerEventPayload) => {\n    if (modifiers.shift && !payload.event.shiftKey) return false;\n    if (modifiers.ctrl && !(payload.event.ctrlKey || payload.event.metaKey)) return false;\n    return true;\n  };\n\n// Usage\nconst isPencilActive = createPluginFilter('pencil');\nconst isShiftPressed = createModifierFilter({ shift: true });\n\neventBus.subscribe('pointerdown', (payload) => {\n  if (!isPencilActive(payload)) return;\n  if (!isShiftPressed(payload)) return;\n  \n  // Handle Shift+Click in pencil mode\n  handleShiftClick(payload.point);\n});\n"})}),"\n",(0,a.jsx)(n.h3,{id:"event-composition",children:"Event Composition"}),"\n",(0,a.jsx)(n.p,{children:"Compose multiple event handlers:"}),"\n",(0,a.jsx)(n.pre,{children:(0,a.jsx)(n.code,{className:"language-typescript",children:"type EventHandler = (payload: CanvasPointerEventPayload) => void;\n\nconst composeHandlers = (...handlers: EventHandler[]): EventHandler =>\n  (payload) => handlers.forEach(handler => handler(payload));\n\nconst logHandler: EventHandler = (payload) => {\n  console.log('Event:', payload.point);\n};\n\nconst drawHandler: EventHandler = (payload) => {\n  updatePath(payload.point);\n};\n\nconst saveHandler: EventHandler = (payload) => {\n  saveToHistory(payload.point);\n};\n\n// Compose multiple handlers into one\nconst composedHandler = composeHandlers(\n  logHandler,\n  drawHandler,\n  saveHandler\n);\n\neventBus.subscribe('pointermove', composedHandler);\n"})}),"\n",(0,a.jsx)(n.h3,{id:"cross-plugin-communication",children:"Cross-Plugin Communication"}),"\n",(0,a.jsx)(n.p,{children:"Plugins can communicate through the event bus:"}),"\n",(0,a.jsx)(n.pre,{children:(0,a.jsx)(n.code,{className:"language-typescript",children:"// Plugin A emits a custom event\neventBus.emit('pointerdown', {\n  event: syntheticEvent,\n  point: calculatedPoint,\n  target: null,\n  activePlugin: 'plugin-a',\n  helpers,\n  state,\n});\n\n// Plugin B listens for Plugin A's events\neventBus.subscribe('pointerdown', (payload) => {\n  if (payload.activePlugin === 'plugin-a') {\n    respondToPluginA(payload);\n  }\n});\n"})}),"\n",(0,a.jsxs)(n.p,{children:[(0,a.jsx)(n.strong,{children:"Communication Flow"}),":"]}),"\n",(0,a.jsx)(n.mermaid,{value:"sequenceDiagram\n    participant PluginA\n    participant EventBus\n    participant PluginB\n    participant PluginC\n    \n    PluginA->>EventBus: emit('pointerdown', payload)\n    EventBus->>PluginA: notify (ignores self)\n    EventBus->>PluginB: notify\n    PluginB->>PluginB: Check activePlugin\n    PluginB->>PluginB: Respond to Plugin A\n    EventBus->>PluginC: notify\n    PluginC->>PluginC: Ignore (not relevant)"}),"\n",(0,a.jsx)(n.h2,{id:"testing-patterns",children:"Testing Patterns"}),"\n",(0,a.jsx)(n.h3,{id:"mock-event-bus",children:"Mock Event Bus"}),"\n",(0,a.jsx)(n.pre,{children:(0,a.jsx)(n.code,{className:"language-typescript",children:"import { describe, it, expect, vi } from 'vitest';\n\ndescribe('MyPlugin', () => {\n  it('should handle pointerdown events', () => {\n    const mockEventBus = {\n      subscribe: vi.fn(),\n      emit: vi.fn(),\n      clear: vi.fn(),\n    };\n    \n    const plugin = new MyPlugin(mockEventBus);\n    \n    expect(mockEventBus.subscribe).toHaveBeenCalledWith(\n      'pointerdown',\n      expect.any(Function)\n    );\n  });\n});\n"})}),"\n",(0,a.jsx)(n.h3,{id:"simulate-events",children:"Simulate Events"}),"\n",(0,a.jsx)(n.pre,{children:(0,a.jsx)(n.code,{className:"language-typescript",children:"import { eventBus } from '@/canvas/eventBus';\n\ndescribe('Event handling', () => {\n  it('should respond to simulated events', () => {\n    const spy = vi.fn();\n    \n    eventBus.subscribe('pointerdown', spy);\n    \n    // Simulate event\n    eventBus.emit('pointerdown', {\n      event: new PointerEvent('pointerdown'),\n      point: { x: 100, y: 100 },\n      target: null,\n      activePlugin: 'test-plugin',\n      helpers: mockHelpers,\n      state: mockState,\n    });\n    \n    expect(spy).toHaveBeenCalledTimes(1);\n  });\n});\n"})}),"\n",(0,a.jsx)(n.h2,{id:"anti-patterns-to-avoid",children:"Anti-Patterns to Avoid"}),"\n",(0,a.jsx)(n.h3,{id:"-forgetting-to-unsubscribe",children:"\u274c Forgetting to Unsubscribe"}),"\n",(0,a.jsx)(n.pre,{children:(0,a.jsx)(n.code,{className:"language-typescript",children:"// BAD: Memory leak\nuseEffect(() => {\n  eventBus.subscribe('pointermove', handler);\n  // Missing cleanup!\n}, []);\n\n// GOOD: Proper cleanup\nuseEffect(() => {\n  const unsubscribe = eventBus.subscribe('pointermove', handler);\n  return unsubscribe;\n}, []);\n"})}),"\n",(0,a.jsx)(n.h3,{id:"-mutating-payload",children:"\u274c Mutating Payload"}),"\n",(0,a.jsx)(n.pre,{children:(0,a.jsx)(n.code,{className:"language-typescript",children:"// BAD: Modifying event payload\neventBus.subscribe('pointerdown', (payload) => {\n  payload.point.x += 10; // Don't mutate!\n});\n\n// GOOD: Create new objects\neventBus.subscribe('pointerdown', (payload) => {\n  const adjustedPoint = {\n    x: payload.point.x + 10,\n    y: payload.point.y,\n  };\n  usePoint(adjustedPoint);\n});\n"})}),"\n",(0,a.jsx)(n.h3,{id:"-heavy-computation-in-handlers",children:"\u274c Heavy Computation in Handlers"}),"\n",(0,a.jsx)(n.pre,{children:(0,a.jsx)(n.code,{className:"language-typescript",children:"// BAD: Blocking operation\neventBus.subscribe('pointermove', (payload) => {\n  expensiveCalculation(); // Runs on every move!\n});\n\n// GOOD: Debounce or throttle\nconst debouncedCalc = debounce(expensiveCalculation, 100);\neventBus.subscribe('pointermove', () => {\n  debouncedCalc();\n});\n"})}),"\n",(0,a.jsx)(n.h3,{id:"-circular-event-emissions",children:"\u274c Circular Event Emissions"}),"\n",(0,a.jsx)(n.pre,{children:(0,a.jsx)(n.code,{className:"language-typescript",children:"// BAD: Infinite loop\neventBus.subscribe('pointerdown', (payload) => {\n  eventBus.emit('pointerdown', payload); // Re-emits same event!\n});\n\n// GOOD: Break the cycle\neventBus.subscribe('pointerdown', (payload) => {\n  if (shouldPropagate(payload)) {\n    eventBus.emit('customEvent', transformPayload(payload));\n  }\n});\n"})}),"\n",(0,a.jsx)(n.h2,{id:"pattern-summary",children:"Pattern Summary"}),"\n",(0,a.jsxs)(n.table,{children:[(0,a.jsx)(n.thead,{children:(0,a.jsxs)(n.tr,{children:[(0,a.jsx)(n.th,{children:"Pattern"}),(0,a.jsx)(n.th,{children:"Use Case"}),(0,a.jsx)(n.th,{children:"Performance Impact"})]})}),(0,a.jsxs)(n.tbody,{children:[(0,a.jsxs)(n.tr,{children:[(0,a.jsx)(n.td,{children:"Plugin-scoped"}),(0,a.jsx)(n.td,{children:"Most handlers"}),(0,a.jsx)(n.td,{children:"Low (early exit)"})]}),(0,a.jsxs)(n.tr,{children:[(0,a.jsx)(n.td,{children:"Multi-phase"}),(0,a.jsx)(n.td,{children:"Drag operations"}),(0,a.jsx)(n.td,{children:"Medium"})]}),(0,a.jsxs)(n.tr,{children:[(0,a.jsx)(n.td,{children:"Modifier-based"}),(0,a.jsx)(n.td,{children:"Conditional behavior"}),(0,a.jsx)(n.td,{children:"Low"})]}),(0,a.jsxs)(n.tr,{children:[(0,a.jsx)(n.td,{children:"State-dependent"}),(0,a.jsx)(n.td,{children:"Context-aware actions"}),(0,a.jsx)(n.td,{children:"Low"})]}),(0,a.jsxs)(n.tr,{children:[(0,a.jsx)(n.td,{children:"Debounced"}),(0,a.jsx)(n.td,{children:"Expensive operations"}),(0,a.jsx)(n.td,{children:"High benefit"})]}),(0,a.jsxs)(n.tr,{children:[(0,a.jsx)(n.td,{children:"Throttled"}),(0,a.jsx)(n.td,{children:"Frequent events"}),(0,a.jsx)(n.td,{children:"High benefit"})]}),(0,a.jsxs)(n.tr,{children:[(0,a.jsx)(n.td,{children:"Batch updates"}),(0,a.jsx)(n.td,{children:"Multiple rapid events"}),(0,a.jsx)(n.td,{children:"High benefit"})]}),(0,a.jsxs)(n.tr,{children:[(0,a.jsx)(n.td,{children:"Early exit"}),(0,a.jsx)(n.td,{children:"All handlers"}),(0,a.jsx)(n.td,{children:"High benefit"})]})]})]}),"\n",(0,a.jsx)(n.h2,{id:"related-documentation",children:"Related Documentation"}),"\n",(0,a.jsxs)(n.ul,{children:["\n",(0,a.jsxs)(n.li,{children:[(0,a.jsx)(n.strong,{children:(0,a.jsx)(n.a,{href:"./overview",children:"Event Bus Overview"})}),": Core architecture and concepts"]}),"\n",(0,a.jsxs)(n.li,{children:[(0,a.jsx)(n.strong,{children:(0,a.jsx)(n.a,{href:"./topics",children:"Event Topics"})}),": Complete payload type reference"]}),"\n",(0,a.jsxs)(n.li,{children:[(0,a.jsx)(n.strong,{children:(0,a.jsx)(n.a,{href:"../plugins/registration",children:"Plugin Registration"})}),": Building plugins with events"]}),"\n",(0,a.jsxs)(n.li,{children:[(0,a.jsx)(n.strong,{children:(0,a.jsx)(n.a,{href:"../architecture/overview",children:"Architecture Overview"})}),": System-wide design and patterns"]}),"\n"]})]})}function p(e={}){const{wrapper:n}={...(0,s.R)(),...e.components};return n?(0,a.jsx)(n,{...e,children:(0,a.jsx)(c,{...e})}):c(e)}},8453:(e,n,t)=>{t.d(n,{R:()=>r,x:()=>l});var i=t(6540);const a={},s=i.createContext(a);function r(e){const n=i.useContext(s);return i.useMemo(function(){return"function"==typeof e?e(n):{...n,...e}},[n,e])}function l(e){let n;return n=e.disableParentContext?"function"==typeof e.components?e.components(a):e.components||a:r(e.components),i.createElement(s.Provider,{value:n},e.children)}}}]);