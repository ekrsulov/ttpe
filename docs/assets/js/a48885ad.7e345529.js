"use strict";(self.webpackChunkttpe_docs=self.webpackChunkttpe_docs||[]).push([[7790],{2348:(e,n,t)=>{t.r(n),t.d(n,{assets:()=>o,contentTitle:()=>s,default:()=>d,frontMatter:()=>r,metadata:()=>i,toc:()=>c});const i=JSON.parse('{"id":"api/create-api","title":"createApi Pattern","description":"The createApi function is the mechanism by which plugins expose public methods to other parts of the application. This enables controlled inter-plugin communication and allows external code to interact with plugin functionality in a type-safe, documented manner.","source":"@site/docs/api/create-api.md","sourceDirName":"api","slug":"/api/create-api","permalink":"/ttpe/docs/api/create-api","draft":false,"unlisted":false,"editUrl":"https://github.com/ekrsulov/ttpe/tree/main/doc/docs/api/create-api.md","tags":[],"version":"current","lastUpdatedBy":"Ernesto Krsulovic","lastUpdatedAt":1762144179000,"frontMatter":{"id":"create-api","title":"createApi Pattern","sidebar_label":"createApi"},"sidebar":"docs","previous":{"title":"Patterns","permalink":"/ttpe/docs/event-bus/patterns"},"next":{"title":"Plugin Manager","permalink":"/ttpe/docs/api/plugin-manager"}}');var a=t(4848),l=t(8453);const r={id:"create-api",title:"createApi Pattern",sidebar_label:"createApi"},s="createApi Pattern",o={},c=[{value:"Why Public APIs?",id:"why-public-apis",level:2},{value:"Architecture",id:"architecture",level:2},{value:"Basic Structure",id:"basic-structure",level:2},{value:"Plugin Definition with createApi",id:"plugin-definition-with-createapi",level:3},{value:"Context Object",id:"context-object",level:3},{value:"Type Safety",id:"type-safety",level:2},{value:"Defining API Types",id:"defining-api-types",level:3},{value:"Type-Safe Consumption",id:"type-safe-consumption",level:3},{value:"Accessing Plugin APIs",id:"accessing-plugin-apis",level:2},{value:"From Other Plugins",id:"from-other-plugins",level:3},{value:"From UI Components",id:"from-ui-components",level:3},{value:"From Event Handlers",id:"from-event-handlers",level:3},{value:"API Call Flow",id:"api-call-flow",level:2},{value:"Real-World Examples",id:"real-world-examples",level:2},{value:"Example 1: Subpath Plugin",id:"example-1-subpath-plugin",level:3},{value:"Example 2: Grid Fill Plugin",id:"example-2-grid-fill-plugin",level:3},{value:"Example 3: Shape Plugin",id:"example-3-shape-plugin",level:3},{value:"Best Practices",id:"best-practices",level:2},{value:"1. Keep APIs Minimal",id:"1-keep-apis-minimal",level:3},{value:"2. Return Immutable Data",id:"2-return-immutable-data",level:3},{value:"3. Handle Errors Gracefully",id:"3-handle-errors-gracefully",level:3},{value:"4. Document Types Thoroughly",id:"4-document-types-thoroughly",level:3},{value:"5. Use Semantic Versioning for Breaking Changes",id:"5-use-semantic-versioning-for-breaking-changes",level:3},{value:"Advanced Patterns",id:"advanced-patterns",level:2},{value:"Async APIs",id:"async-apis",level:3},{value:"Chaining APIs",id:"chaining-apis",level:3},{value:"Event-Based APIs",id:"event-based-apis",level:3},{value:"Testing Plugin APIs",id:"testing-plugin-apis",level:2},{value:"Related Documentation",id:"related-documentation",level:2}];function p(e){const n={a:"a",code:"code",h1:"h1",h2:"h2",h3:"h3",header:"header",li:"li",mermaid:"mermaid",ol:"ol",p:"p",pre:"pre",strong:"strong",ul:"ul",...(0,l.R)(),...e.components};return(0,a.jsxs)(a.Fragment,{children:[(0,a.jsx)(n.header,{children:(0,a.jsx)(n.h1,{id:"createapi-pattern",children:"createApi Pattern"})}),"\n",(0,a.jsxs)(n.p,{children:["The ",(0,a.jsx)(n.code,{children:"createApi"})," function is the mechanism by which plugins expose ",(0,a.jsx)(n.strong,{children:"public methods"})," to other parts of the application. This enables controlled inter-plugin communication and allows external code to interact with plugin functionality in a type-safe, documented manner."]}),"\n",(0,a.jsx)(n.h2,{id:"why-public-apis",children:"Why Public APIs?"}),"\n",(0,a.jsx)(n.p,{children:"Plugins often implement functionality that other plugins or UI components need to access:"}),"\n",(0,a.jsxs)(n.ul,{children:["\n",(0,a.jsxs)(n.li,{children:[(0,a.jsx)(n.strong,{children:"Subpath plugin"})," exposes ",(0,a.jsx)(n.code,{children:"performPathSimplify()"})," to simplify paths programmatically"]}),"\n",(0,a.jsxs)(n.li,{children:[(0,a.jsx)(n.strong,{children:"GridFill plugin"})," exposes ",(0,a.jsx)(n.code,{children:"fillGridCell()"})," for scripted grid filling"]}),"\n",(0,a.jsxs)(n.li,{children:[(0,a.jsx)(n.strong,{children:"Shape plugin"})," exposes ",(0,a.jsx)(n.code,{children:"createShape()"})," to generate shapes from code"]}),"\n"]}),"\n",(0,a.jsxs)(n.p,{children:["Without ",(0,a.jsx)(n.code,{children:"createApi"}),", plugins would need to:"]}),"\n",(0,a.jsxs)(n.ol,{children:["\n",(0,a.jsx)(n.li,{children:"Expose internal state directly (breaks encapsulation)"}),"\n",(0,a.jsx)(n.li,{children:"Use global functions (loses type safety)"}),"\n",(0,a.jsx)(n.li,{children:"Directly import plugin modules (creates tight coupling)"}),"\n"]}),"\n",(0,a.jsxs)(n.p,{children:["The ",(0,a.jsx)(n.code,{children:"createApi"})," pattern solves these problems by providing a clean, type-safe interface."]}),"\n",(0,a.jsx)(n.h2,{id:"architecture",children:"Architecture"}),"\n",(0,a.jsx)(n.mermaid,{value:'graph TB\n    subgraph "Plugin Definition"\n        Plugin[Plugin Object]\n        CreateAPI[createApi Function]\n        API[Public API Object]\n    end\n    \n    subgraph "Plugin Manager"\n        PM[PluginManager]\n        Registry[API Registry]\n    end\n    \n    subgraph "Consumers"\n        OtherPlugin[Other Plugins]\n        UI[UI Components]\n        Scripts[External Scripts]\n    end\n    \n    Plugin --\x3e CreateAPI\n    CreateAPI --\x3e API\n    API --\x3e PM\n    PM --\x3e Registry\n    \n    OtherPlugin --\x3e|getPluginApi| PM\n    UI --\x3e|getPluginApi| PM\n    Scripts --\x3e|getPluginApi| PM\n    \n    PM --\x3e|returns| API'}),"\n",(0,a.jsx)(n.h2,{id:"basic-structure",children:"Basic Structure"}),"\n",(0,a.jsx)(n.h3,{id:"plugin-definition-with-createapi",children:"Plugin Definition with createApi"}),"\n",(0,a.jsx)(n.pre,{children:(0,a.jsx)(n.code,{className:"language-typescript",children:"import { PluginDefinition } from '@/types/plugins';\nimport type { CanvasStore } from '@/store/canvasStore';\n\nexport const myPlugin: PluginDefinition<CanvasStore> = {\n  id: 'my-plugin',\n  metadata: {\n    label: 'My Plugin',\n    icon: MyIcon,\n  },\n  \n  // Public API definition\n  createApi: (context) => ({\n    // Method 1: Simple calculation\n    calculateBounds: (elementId: string): Bounds | null => {\n      const state = context.store.getState();\n      const element = state.elements.find(e => e.id === elementId);\n      return element ? computeBounds(element) : null;\n    },\n    \n    // Method 2: State manipulation\n    simplifyPath: (pathId: string, tolerance: number): boolean => {\n      const state = context.store.getState();\n      const path = state.elements.find(e => e.id === pathId);\n      \n      if (!path || path.type !== 'path') return false;\n      \n      const simplified = simplifyPathData(path.d, tolerance);\n      context.store.getState().updateElement(pathId, { d: simplified });\n      return true;\n    },\n  }),\n  \n  // ... rest of plugin definition (handler, keyboardShortcuts, etc.)\n};\n"})}),"\n",(0,a.jsx)(n.h3,{id:"context-object",children:"Context Object"}),"\n",(0,a.jsxs)(n.p,{children:["The ",(0,a.jsx)(n.code,{children:"context"})," parameter provides access to the Canvas Store:"]}),"\n",(0,a.jsx)(n.pre,{children:(0,a.jsx)(n.code,{className:"language-typescript",children:"interface PluginApiContext<TStore> {\n  // Zustand store for state management\n  store: PluginStoreApi<TStore>;\n}\n"})}),"\n",(0,a.jsxs)(n.p,{children:[(0,a.jsx)(n.strong,{children:"Note"}),": The context object ",(0,a.jsxs)(n.strong,{children:["only contains the ",(0,a.jsx)(n.code,{children:"store"})]}),". It does not include:"]}),"\n",(0,a.jsxs)(n.ul,{children:["\n",(0,a.jsxs)(n.li,{children:["\u274c ",(0,a.jsx)(n.code,{children:"eventBus"})," - Event Bus is accessed separately via hooks/contexts"]}),"\n",(0,a.jsxs)(n.li,{children:["\u274c ",(0,a.jsx)(n.code,{children:"pluginManager"})," - Plugin Manager is not injected into API context"]}),"\n",(0,a.jsxs)(n.li,{children:["\u274c ",(0,a.jsx)(n.code,{children:"name"})," - Plugin metadata uses ",(0,a.jsx)(n.code,{children:"metadata.label"})," instead"]}),"\n"]}),"\n",(0,a.jsx)(n.p,{children:"This allows APIs to:"}),"\n",(0,a.jsxs)(n.ul,{children:["\n",(0,a.jsxs)(n.li,{children:["Read store state via ",(0,a.jsx)(n.code,{children:"context.store.getState()"})]}),"\n",(0,a.jsx)(n.li,{children:"Modify state by calling store methods"}),"\n",(0,a.jsxs)(n.li,{children:["Subscribe to state changes via ",(0,a.jsx)(n.code,{children:"context.store.subscribe()"})]}),"\n"]}),"\n",(0,a.jsx)(n.h2,{id:"type-safety",children:"Type Safety"}),"\n",(0,a.jsx)(n.h3,{id:"defining-api-types",children:"Defining API Types"}),"\n",(0,a.jsx)(n.p,{children:"Always define TypeScript interfaces for your APIs:"}),"\n",(0,a.jsx)(n.pre,{children:(0,a.jsx)(n.code,{className:"language-typescript",children:"// Define the API interface\nexport interface SubpathPluginAPI {\n  performPathSimplify: () => void;\n  performSubPathReverse: () => void;\n}\n\n// Implement the interface\nexport const subpathPlugin: PluginDefinition<CanvasStore> = {\n  id: 'subpath',\n  metadata: {\n    label: 'Subpath',\n    icon: SubpathIcon,\n  },\n  \n  createApi: (context): SubpathPluginAPI => ({\n    performPathSimplify: () => {\n      performPathSimplify(context.store.getState);\n    },\n    \n    performSubPathReverse: () => {\n      performSubPathReverse(context.store.getState);\n    },\n  }),\n};\n"})}),"\n",(0,a.jsx)(n.h3,{id:"type-safe-consumption",children:"Type-Safe Consumption"}),"\n",(0,a.jsx)(n.pre,{children:(0,a.jsx)(n.code,{className:"language-typescript",children:"import { SubpathPluginAPI } from '@/plugins/subpath';\n\n// Type-safe API access\nconst api = pluginManager.getPluginApi<SubpathPluginAPI>('subpath');\n\nif (api) {\n  api.performPathSimplify(); // \u2713 Type-checked\n  api.invalidMethod();       // \u2717 TypeScript error\n}\n"})}),"\n",(0,a.jsx)(n.h2,{id:"accessing-plugin-apis",children:"Accessing Plugin APIs"}),"\n",(0,a.jsx)(n.h3,{id:"from-other-plugins",children:"From Other Plugins"}),"\n",(0,a.jsx)(n.pre,{children:(0,a.jsx)(n.code,{className:"language-typescript",children:"export const myPlugin: PluginDefinition = {\n  id: 'my-plugin',\n  \n  activate: (context) => {\n    // Access another plugin's API\n    const gridFillAPI = context.pluginManager.getPluginApi<GridFillAPI>('gridFill');\n    \n    if (gridFillAPI) {\n      gridFillAPI.fillGridCell({ x: 100, y: 100 });\n    }\n  },\n};\n"})}),"\n",(0,a.jsx)(n.h3,{id:"from-ui-components",children:"From UI Components"}),"\n",(0,a.jsx)(n.pre,{children:(0,a.jsx)(n.code,{className:"language-typescript",children:"import { useCanvasStore } from '@/store/canvasStore';\nimport { pluginManager } from '@/plugins/pluginManager';\n\nfunction MyButton() {\n  const handleClick = () => {\n    const api = pluginManager.getPluginApi<SubpathPluginAPI>('subpath');\n    \n    if (api) {\n      api.performPathSimplify();\n    } else {\n      console.warn('Subpath plugin not available');\n    }\n  };\n  \n  return <button onClick={handleClick}>Simplify Path</button>;\n}\n"})}),"\n",(0,a.jsx)(n.h3,{id:"from-event-handlers",children:"From Event Handlers"}),"\n",(0,a.jsx)(n.pre,{children:(0,a.jsx)(n.code,{className:"language-typescript",children:"eventBus.subscribe('keyboard', (payload) => {\n  if (payload.event.key === 's' && payload.event.ctrlKey) {\n    const shapeAPI = pluginManager.getPluginApi<ShapeAPI>('shape');\n    \n    if (shapeAPI) {\n      shapeAPI.createShape({ x: 0, y: 0 }, { x: 100, y: 100 });\n    }\n  }\n});\n"})}),"\n",(0,a.jsx)(n.h2,{id:"api-call-flow",children:"API Call Flow"}),"\n",(0,a.jsx)(n.mermaid,{value:"sequenceDiagram\n    participant Consumer as UI Component\n    participant PM as Plugin Manager\n    participant Registry as API Registry\n    participant API as Plugin API\n    participant Store as Canvas Store\n    \n    Consumer->>PM: getPluginApi('subpath')\n    PM->>Registry: Lookup 'subpath'\n    Registry--\x3e>PM: Return API object\n    PM--\x3e>Consumer: Return SubpathPluginAPI\n    \n    Consumer->>API: performPathSimplify()\n    API->>Store: getState()\n    Store--\x3e>API: Current state\n    API->>API: Simplify path logic\n    API->>Store: updateElement()\n    Store->>Store: Update state\n    Store--\x3e>API: Success\n    API--\x3e>Consumer: void (completed)"}),"\n",(0,a.jsx)(n.h2,{id:"real-world-examples",children:"Real-World Examples"}),"\n",(0,a.jsx)(n.h3,{id:"example-1-subpath-plugin",children:"Example 1: Subpath Plugin"}),"\n",(0,a.jsx)(n.pre,{children:(0,a.jsx)(n.code,{className:"language-typescript",children:"export interface SubpathPluginAPI {\n  performPathSimplify: () => void;\n  performSubPathReverse: () => void;\n}\n\nexport const subpathPlugin: PluginDefinition<CanvasStore> = {\n  id: 'subpath',\n  metadata: {\n    label: 'Subpath',\n    icon: SubpathIcon,\n  },\n  \n  createApi: ({ store }): SubpathPluginAPI => ({\n    performPathSimplify: () => {\n      performPathSimplify(store.getState);\n    },\n    \n    performSubPathReverse: () => {\n      performSubPathReverse(store.getState);\n    },\n  }),\n};\n"})}),"\n",(0,a.jsxs)(n.p,{children:[(0,a.jsx)(n.strong,{children:"Usage"}),":"]}),"\n",(0,a.jsx)(n.pre,{children:(0,a.jsx)(n.code,{className:"language-typescript",children:"const api = pluginManager.getPluginApi<SubpathPluginAPI>('subpath');\napi?.performPathSimplify();\n"})}),"\n",(0,a.jsx)(n.h3,{id:"example-2-grid-fill-plugin",children:"Example 2: Grid Fill Plugin"}),"\n",(0,a.jsx)(n.pre,{children:(0,a.jsx)(n.code,{className:"language-typescript",children:"export interface GridFillAPI {\n  fillGridCell: (point: Point) => void;\n}\n\nexport const gridFillPlugin: PluginDefinition<CanvasStore> = {\n  id: 'gridFill',\n  metadata: {\n    label: 'Grid Fill',\n    icon: GridFillIcon,\n  },\n  \n  createApi: ({ store }): GridFillAPI => ({\n    fillGridCell: (point: Point) => {\n      return fillGridCell(point, store.getState);\n    },\n  }),\n};\n"})}),"\n",(0,a.jsxs)(n.p,{children:[(0,a.jsx)(n.strong,{children:"Usage"}),":"]}),"\n",(0,a.jsx)(n.pre,{children:(0,a.jsx)(n.code,{className:"language-typescript",children:"const api = pluginManager.getPluginApi<GridFillAPI>('gridFill');\napi?.fillGridCell({ x: 150, y: 200 });\n"})}),"\n",(0,a.jsx)(n.h3,{id:"example-3-shape-plugin",children:"Example 3: Shape Plugin"}),"\n",(0,a.jsx)(n.pre,{children:(0,a.jsx)(n.code,{className:"language-typescript",children:"export interface ShapeAPI {\n  createShape: (startPoint: Point, endPoint: Point) => void;\n}\n\nexport const shapePlugin: PluginDefinition<CanvasStore> = {\n  id: 'shape',\n  metadata: {\n    label: 'Shape',\n    icon: ShapeIcon,\n  },\n  \n  createApi: ({ store }): ShapeAPI => ({\n    createShape: (startPoint: Point, endPoint: Point) => {\n      createShape(startPoint, endPoint, store.getState);\n    },\n  }),\n};\n"})}),"\n",(0,a.jsxs)(n.p,{children:[(0,a.jsx)(n.strong,{children:"Usage"}),":"]}),"\n",(0,a.jsx)(n.pre,{children:(0,a.jsx)(n.code,{className:"language-typescript",children:"const api = pluginManager.getPluginApi<ShapeAPI>('shape');\napi?.createShape({ x: 0, y: 0 }, { x: 100, y: 100 });\n"})}),"\n",(0,a.jsx)(n.h2,{id:"best-practices",children:"Best Practices"}),"\n",(0,a.jsx)(n.h3,{id:"1-keep-apis-minimal",children:"1. Keep APIs Minimal"}),"\n",(0,a.jsx)(n.p,{children:"Only expose what's necessary:"}),"\n",(0,a.jsx)(n.pre,{children:(0,a.jsx)(n.code,{className:"language-typescript",children:"// \u274c BAD: Exposing internal state\ncreateApi: (context) => ({\n  getInternalState: () => context.store.getState().myPlugin,\n  setInternalState: (state) => { /* ... */ },\n});\n\n// \u2705 GOOD: Focused, high-level operations\ncreateApi: (context) => ({\n  simplifyPath: (tolerance: number) => { /* ... */ },\n  reversePath: () => { /* ... */ },\n});\n"})}),"\n",(0,a.jsx)(n.h3,{id:"2-return-immutable-data",children:"2. Return Immutable Data"}),"\n",(0,a.jsx)(n.p,{children:"Never return mutable references:"}),"\n",(0,a.jsx)(n.pre,{children:(0,a.jsx)(n.code,{className:"language-typescript",children:"// \u274c BAD: Returning mutable object\ncreateApi: (context) => ({\n  getElements: () => context.store.getState().elements,\n});\n\n// \u2705 GOOD: Return copy or specific data\ncreateApi: (context) => ({\n  getElementIds: () => [...context.store.getState().elements.map(e => e.id)],\n  getElementById: (id: string) => {\n    const element = context.store.getState().elements.find(e => e.id === id);\n    return element ? { ...element } : null;\n  },\n});\n"})}),"\n",(0,a.jsx)(n.h3,{id:"3-handle-errors-gracefully",children:"3. Handle Errors Gracefully"}),"\n",(0,a.jsx)(n.pre,{children:(0,a.jsx)(n.code,{className:"language-typescript",children:"createApi: (context) => ({\n  simplifyPath: (pathId: string, tolerance: number): boolean => {\n    try {\n      const state = context.store.getState();\n      const path = state.elements.find(e => e.id === pathId);\n      \n      if (!path) {\n        console.warn(`Path ${pathId} not found`);\n        return false;\n      }\n      \n      if (path.type !== 'path') {\n        console.warn(`Element ${pathId} is not a path`);\n        return false;\n      }\n      \n      // Perform operation\n      const simplified = simplifyPathData(path.d, tolerance);\n      state.updateElement(pathId, { d: simplified });\n      return true;\n      \n    } catch (error) {\n      console.error('Error simplifying path:', error);\n      return false;\n    }\n  },\n});\n"})}),"\n",(0,a.jsx)(n.h3,{id:"4-document-types-thoroughly",children:"4. Document Types Thoroughly"}),"\n",(0,a.jsx)(n.pre,{children:(0,a.jsx)(n.code,{className:"language-typescript",children:"export interface MyPluginAPI {\n  /**\n   * Calculate the bounding box for an element\n   * @param elementId - ID of the element to measure\n   * @returns Bounds object or null if element not found\n   */\n  calculateBounds: (elementId: string) => Bounds | null;\n  \n  /**\n   * Simplify a path using Douglas-Peucker algorithm\n   * @param pathId - ID of the path element\n   * @param tolerance - Simplification tolerance (higher = more simplified)\n   * @returns true if successful, false if path not found or invalid\n   */\n  simplifyPath: (pathId: string, tolerance: number) => boolean;\n}\n"})}),"\n",(0,a.jsx)(n.h3,{id:"5-use-semantic-versioning-for-breaking-changes",children:"5. Use Semantic Versioning for Breaking Changes"}),"\n",(0,a.jsx)(n.p,{children:"If you must change an API, version it:"}),"\n",(0,a.jsx)(n.pre,{children:(0,a.jsx)(n.code,{className:"language-typescript",children:"export interface MyPluginAPI_V1 {\n  doSomething: (arg: string) => void;\n}\n\nexport interface MyPluginAPI_V2 {\n  doSomething: (arg: string, options?: Options) => Promise<void>;\n}\n\n// Support both versions temporarily\ncreateApi: (context) => ({\n  // V2 implementation\n  doSomething: async (arg: string, options?: Options) => { /* ... */ },\n  \n  // V1 compatibility (deprecated)\n  doSomethingV1: (arg: string) => { /* ... */ },\n});\n"})}),"\n",(0,a.jsx)(n.h2,{id:"advanced-patterns",children:"Advanced Patterns"}),"\n",(0,a.jsx)(n.h3,{id:"async-apis",children:"Async APIs"}),"\n",(0,a.jsx)(n.pre,{children:(0,a.jsx)(n.code,{className:"language-typescript",children:"createApi: (context) => ({\n  loadExternalData: async (url: string): Promise<Data> => {\n    const response = await fetch(url);\n    const data = await response.json();\n    return processData(data);\n  },\n});\n\n// Usage\nconst api = pluginManager.getPluginApi<MyAPI>('my-plugin');\nconst data = await api?.loadExternalData('https://...');\n"})}),"\n",(0,a.jsx)(n.h3,{id:"chaining-apis",children:"Chaining APIs"}),"\n",(0,a.jsx)(n.pre,{children:(0,a.jsx)(n.code,{className:"language-typescript",children:"createApi: (context) => ({\n  selectElement: (id: string) => {\n    context.store.getState().selectElement(id);\n    return api; // Return self for chaining\n  },\n  \n  moveSelection: (dx: number, dy: number) => {\n    context.store.getState().moveSelectedElements(dx, dy);\n    return api;\n  },\n});\n\n// Usage: Chain multiple operations\napi?.selectElement('element-1')\n    .moveSelection(10, 20);\n"})}),"\n",(0,a.jsx)(n.h3,{id:"event-based-apis",children:"Event-Based APIs"}),"\n",(0,a.jsx)(n.pre,{children:(0,a.jsx)(n.code,{className:"language-typescript",children:"createApi: (context) => ({\n  onPathChanged: (callback: (pathId: string) => void) => {\n    const unsubscribe = context.eventBus.subscribe('pathChanged', (payload) => {\n      callback(payload.pathId);\n    });\n    return unsubscribe;\n  },\n});\n\n// Usage\nconst unsubscribe = api?.onPathChanged((pathId) => {\n  console.log('Path changed:', pathId);\n});\n\n// Cleanup\nunsubscribe?.();\n"})}),"\n",(0,a.jsx)(n.h2,{id:"testing-plugin-apis",children:"Testing Plugin APIs"}),"\n",(0,a.jsx)(n.pre,{children:(0,a.jsx)(n.code,{className:"language-typescript",children:"import { describe, it, expect, vi } from 'vitest';\n\ndescribe('MyPlugin API', () => {\n  it('should expose correct API methods', () => {\n    const mockContext = {\n      store: mockStore,\n      eventBus: mockEventBus,\n      pluginManager: mockPluginManager,\n    };\n    \n    const api = myPlugin.createApi!(mockContext);\n    \n    expect(api).toHaveProperty('calculateBounds');\n    expect(typeof api.calculateBounds).toBe('function');\n  });\n  \n  it('should calculate bounds correctly', () => {\n    const api = myPlugin.createApi!(mockContext);\n    const bounds = api.calculateBounds('element-1');\n    \n    expect(bounds).toEqual({\n      x: 0,\n      y: 0,\n      width: 100,\n      height: 100,\n    });\n  });\n});\n"})}),"\n",(0,a.jsx)(n.h2,{id:"related-documentation",children:"Related Documentation"}),"\n",(0,a.jsxs)(n.ul,{children:["\n",(0,a.jsxs)(n.li,{children:[(0,a.jsx)(n.strong,{children:(0,a.jsx)(n.a,{href:"./plugin-manager",children:"Plugin Manager"})}),": Complete PluginManager API reference"]}),"\n",(0,a.jsxs)(n.li,{children:[(0,a.jsx)(n.strong,{children:(0,a.jsx)(n.a,{href:"./canvas-store",children:"Canvas Store"})}),": Store methods available in context"]}),"\n",(0,a.jsxs)(n.li,{children:[(0,a.jsx)(n.strong,{children:(0,a.jsx)(n.a,{href:"../plugins/registration",children:"Plugin Registration"})}),": How to register and configure plugins"]}),"\n",(0,a.jsxs)(n.li,{children:[(0,a.jsx)(n.strong,{children:(0,a.jsx)(n.a,{href:"../plugins/lifecycle",children:"Plugin Lifecycle"})}),": Understanding plugin lifecycle hooks"]}),"\n"]})]})}function d(e={}){const{wrapper:n}={...(0,l.R)(),...e.components};return n?(0,a.jsx)(n,{...e,children:(0,a.jsx)(p,{...e})}):p(e)}},8453:(e,n,t)=>{t.d(n,{R:()=>r,x:()=>s});var i=t(6540);const a={},l=i.createContext(a);function r(e){const n=i.useContext(l);return i.useMemo(function(){return"function"==typeof e?e(n):{...n,...e}},[n,e])}function s(e){let n;return n=e.disableParentContext?"function"==typeof e.components?e.components(a):e.components||a:r(e.components),i.createElement(l.Provider,{value:n},e.children)}}}]);