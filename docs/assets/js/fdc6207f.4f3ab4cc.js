"use strict";(self.webpackChunkttpe_docs=self.webpackChunkttpe_docs||[]).push([[5359],{8453:(e,n,t)=>{t.d(n,{R:()=>r,x:()=>a});var s=t(6540);const i={},l=s.createContext(i);function r(e){const n=s.useContext(l);return s.useMemo(function(){return"function"==typeof e?e(n):{...n,...e}},[n,e])}function a(e){let n;return n=e.disableParentContext?"function"==typeof e.components?e.components(i):e.components||i:r(e.components),s.createElement(l.Provider,{value:n},e.children)}},8503:(e,n,t)=>{t.r(n),t.d(n,{assets:()=>o,contentTitle:()=>a,default:()=>u,frontMatter:()=>r,metadata:()=>s,toc:()=>c});const s=JSON.parse('{"id":"event-bus/overview","title":"Event Bus Overview","description":"The Canvas Event Bus is a type-safe publish/subscribe (pub/sub) system that serves as the communication backbone of TTPE. It decouples plugins from direct canvas manipulation and enables loose coupling between components, allowing them to communicate without explicit dependencies.","source":"@site/docs/event-bus/overview.md","sourceDirName":"event-bus","slug":"/event-bus/overview","permalink":"/ttpe/docs/docs/event-bus/overview","draft":false,"unlisted":false,"editUrl":"https://github.com/ekrsulov/ttpe/tree/main/doc/docs/event-bus/overview.md","tags":[],"version":"current","lastUpdatedBy":"Ernesto Krsulovic","lastUpdatedAt":1762144584000,"frontMatter":{"id":"overview","title":"Event Bus Overview","sidebar_label":"Overview"},"sidebar":"docs","previous":{"title":"Duplicate on Drag","permalink":"/ttpe/docs/docs/plugins/catalog/duplicate-on-drag"},"next":{"title":"Topics","permalink":"/ttpe/docs/docs/event-bus/topics"}}');var i=t(4848),l=t(8453);const r={id:"overview",title:"Event Bus Overview",sidebar_label:"Overview"},a="Event Bus Overview",o={},c=[{value:"Why an Event Bus?",id:"why-an-event-bus",level:2},{value:"Architecture Overview",id:"architecture-overview",level:2},{value:"Core Components",id:"core-components",level:2},{value:"CanvasEventBus Class",id:"canvaseventbus-class",level:3},{value:"Event Map (Type Safety)",id:"event-map-type-safety",level:3},{value:"Event Types",id:"event-types",level:2},{value:"Event Flow Diagram",id:"event-flow-diagram",level:3},{value:"Payload Structure",id:"payload-structure",level:3},{value:"Usage Patterns",id:"usage-patterns",level:2},{value:"1. Basic Subscription",id:"1-basic-subscription",level:3},{value:"2. Plugin-Scoped Handler",id:"2-plugin-scoped-handler",level:3},{value:"3. React Hook Integration",id:"3-react-hook-integration",level:3},{value:"4. Emitting Events (Less Common)",id:"4-emitting-events-less-common",level:3},{value:"Benefits",id:"benefits",level:2},{value:"Decoupling",id:"decoupling",level:3},{value:"Extensibility",id:"extensibility",level:3},{value:"Testability",id:"testability",level:3},{value:"Performance",id:"performance",level:3},{value:"Data Flow Example",id:"data-flow-example",level:2},{value:"Implementation Location",id:"implementation-location",level:2},{value:"Best Practices",id:"best-practices",level:2},{value:"Related Documentation",id:"related-documentation",level:2}];function d(e){const n={a:"a",code:"code",h1:"h1",h2:"h2",h3:"h3",header:"header",li:"li",mermaid:"mermaid",ol:"ol",p:"p",pre:"pre",strong:"strong",table:"table",tbody:"tbody",td:"td",th:"th",thead:"thead",tr:"tr",ul:"ul",...(0,l.R)(),...e.components};return(0,i.jsxs)(i.Fragment,{children:[(0,i.jsx)(n.header,{children:(0,i.jsx)(n.h1,{id:"event-bus-overview",children:"Event Bus Overview"})}),"\n",(0,i.jsxs)(n.p,{children:["The ",(0,i.jsx)(n.strong,{children:"Canvas Event Bus"})," is a type-safe publish/subscribe (pub/sub) system that serves as the communication backbone of TTPE. It decouples plugins from direct canvas manipulation and enables loose coupling between components, allowing them to communicate without explicit dependencies."]}),"\n",(0,i.jsx)(n.h2,{id:"why-an-event-bus",children:"Why an Event Bus?"}),"\n",(0,i.jsx)(n.p,{children:"In a plugin-based architecture, direct coupling between components creates several problems:"}),"\n",(0,i.jsxs)(n.ol,{children:["\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.strong,{children:"Tight coupling"}),": Plugins would need direct references to other plugins or canvas components"]}),"\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.strong,{children:"Circular dependencies"}),": Plugin A imports Plugin B which imports Plugin A"]}),"\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.strong,{children:"Limited extensibility"}),": Adding new plugins requires modifying existing code"]}),"\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.strong,{children:"Testing complexity"}),": Mocking dependencies becomes difficult"]}),"\n"]}),"\n",(0,i.jsx)(n.p,{children:"The Event Bus solves these problems by introducing an intermediary communication layer where:"}),"\n",(0,i.jsxs)(n.ul,{children:["\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.strong,{children:"Publishers"})," emit events without knowing who will handle them"]}),"\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.strong,{children:"Subscribers"})," listen to events without knowing who emitted them"]}),"\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.strong,{children:"Plugins"})," can be added or removed without affecting other components"]}),"\n"]}),"\n",(0,i.jsx)(n.h2,{id:"architecture-overview",children:"Architecture Overview"}),"\n",(0,i.jsx)(n.mermaid,{value:'graph TB\n    subgraph "Canvas Layer"\n        Canvas[Canvas Component]\n    end\n    \n    subgraph "Event Bus"\n        EB[CanvasEventBus<br/>Type-Safe Pub/Sub]\n    end\n    \n    subgraph "Subscribers"\n        P1[Pencil Plugin]\n        P2[Edit Plugin]\n        P3[Transform Plugin]\n        P4[Grid Plugin]\n        UI[UI Components]\n    end\n    \n    Canvas --\x3e|emit| EB\n    EB --\x3e|notify| P1\n    EB --\x3e|notify| P2\n    EB --\x3e|notify| P3\n    EB --\x3e|notify| P4\n    EB --\x3e|notify| UI\n    \n    P1 -.->|can emit| EB\n    P2 -.->|can emit| EB\n    \n    style EB fill:#e1f5ff\n    style Canvas fill:#fff4e1'}),"\n",(0,i.jsx)(n.p,{children:"The Event Bus sits between the canvas layer and all subscribers (plugins, UI components). When the canvas detects user input, it emits typed events through the bus. Subscribers filter and handle only the events relevant to them."}),"\n",(0,i.jsx)(n.h2,{id:"core-components",children:"Core Components"}),"\n",(0,i.jsx)(n.h3,{id:"canvaseventbus-class",children:"CanvasEventBus Class"}),"\n",(0,i.jsx)(n.p,{children:"The central event bus implementation provides three core methods:"}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-typescript",children:"class CanvasEventBus {\n  /**\n   * Subscribe to an event type\n   * @returns Unsubscribe function\n   */\n  subscribe<K extends keyof EventMap>(\n    eventType: K, \n    handler: (payload: EventMap[K]) => void\n  ): () => void;\n  \n  /**\n   * Emit an event to all subscribers\n   */\n  emit<K extends keyof EventMap>(\n    eventType: K, \n    payload: EventMap[K]\n  ): void;\n  \n  /**\n   * Clear all subscriptions (cleanup)\n   */\n  clear(): void;\n}\n"})}),"\n",(0,i.jsx)(n.h3,{id:"event-map-type-safety",children:"Event Map (Type Safety)"}),"\n",(0,i.jsxs)(n.p,{children:["All events are strongly typed through the ",(0,i.jsx)(n.code,{children:"EventMap"})," interface:"]}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-typescript",children:"interface EventMap {\n  pointerdown: CanvasPointerEventPayload;\n  pointermove: CanvasPointerEventPayload;\n  pointerup: CanvasPointerEventPayload;\n  keyboard: CanvasKeyboardEventPayload;\n  wheel: CanvasWheelEventPayload;\n}\n"})}),"\n",(0,i.jsx)(n.p,{children:"This ensures:"}),"\n",(0,i.jsxs)(n.ul,{children:["\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.strong,{children:"Compile-time safety"}),": TypeScript catches invalid event types and payloads"]}),"\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.strong,{children:"IntelliSense support"}),": Auto-completion for event names and payload properties"]}),"\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.strong,{children:"Refactoring confidence"}),": Renaming events or changing payloads updates all usages"]}),"\n"]}),"\n",(0,i.jsx)(n.h2,{id:"event-types",children:"Event Types"}),"\n",(0,i.jsx)(n.p,{children:"TTPE's Event Bus handles five primary event types:"}),"\n",(0,i.jsxs)(n.table,{children:[(0,i.jsx)(n.thead,{children:(0,i.jsxs)(n.tr,{children:[(0,i.jsx)(n.th,{children:"Event Type"}),(0,i.jsx)(n.th,{children:"Trigger"}),(0,i.jsx)(n.th,{children:"Use Cases"})]})}),(0,i.jsxs)(n.tbody,{children:[(0,i.jsxs)(n.tr,{children:[(0,i.jsx)(n.td,{children:(0,i.jsx)(n.strong,{children:"pointerdown"})}),(0,i.jsx)(n.td,{children:"Mouse/touch press on canvas"}),(0,i.jsx)(n.td,{children:"Start drawing, begin selection, initiate drag"})]}),(0,i.jsxs)(n.tr,{children:[(0,i.jsx)(n.td,{children:(0,i.jsx)(n.strong,{children:"pointermove"})}),(0,i.jsx)(n.td,{children:"Mouse/touch movement"}),(0,i.jsx)(n.td,{children:"Continue drawing, drag elements, show cursor feedback"})]}),(0,i.jsxs)(n.tr,{children:[(0,i.jsx)(n.td,{children:(0,i.jsx)(n.strong,{children:"pointerup"})}),(0,i.jsx)(n.td,{children:"Mouse/touch release"}),(0,i.jsx)(n.td,{children:"Complete drawing, end selection, finish drag"})]}),(0,i.jsxs)(n.tr,{children:[(0,i.jsx)(n.td,{children:(0,i.jsx)(n.strong,{children:"keyboard"})}),(0,i.jsx)(n.td,{children:"Key press/release"}),(0,i.jsx)(n.td,{children:"Shortcuts, mode switching, deletion"})]}),(0,i.jsxs)(n.tr,{children:[(0,i.jsx)(n.td,{children:(0,i.jsx)(n.strong,{children:"wheel"})}),(0,i.jsx)(n.td,{children:"Mouse wheel scroll"}),(0,i.jsx)(n.td,{children:"Zoom in/out, pan canvas"})]})]})]}),"\n",(0,i.jsx)(n.h3,{id:"event-flow-diagram",children:"Event Flow Diagram"}),"\n",(0,i.jsx)(n.mermaid,{value:"sequenceDiagram\n    participant User\n    participant Canvas\n    participant EventBus\n    participant Plugin1 as Pencil Plugin\n    participant Plugin2 as Select Plugin\n    \n    User->>Canvas: Click on canvas\n    Canvas->>Canvas: Convert to SVG coords\n    Canvas->>EventBus: emit('pointerdown', payload)\n    \n    EventBus->>Plugin1: notify(payload)\n    Plugin1->>Plugin1: if activePlugin === 'pencil'\n    Plugin1->>Plugin1: Start drawing path\n    \n    EventBus->>Plugin2: notify(payload)\n    Plugin2->>Plugin2: if activePlugin !== 'select'\n    Plugin2->>Plugin2: Ignore event\n    \n    Note over Canvas,Plugin2: Only active plugin handles event"}),"\n",(0,i.jsx)(n.h3,{id:"payload-structure",children:"Payload Structure"}),"\n",(0,i.jsx)(n.p,{children:"Every event carries a rich payload with context:"}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-typescript",children:"interface CanvasPointerEventPayload {\n  event: PointerEvent;              // Raw DOM event\n  point: Point;                     // SVG coordinate space {x, y}\n  target: EventTarget | null;       // DOM element under pointer\n  activePlugin: string | null;      // Currently active tool\n  helpers: {                        // Utility functions\n    getViewportInfo: () => ViewportInfo;\n    getSVGRoot: () => SVGSVGElement | null;\n  };\n  state: {                          // Current canvas state\n    zoom: number;\n    panX: number;\n    panY: number;\n    selectedIds: string[];\n  };\n}\n"})}),"\n",(0,i.jsx)(n.p,{children:"This rich payload eliminates the need for plugins to query the store directly in many cases."}),"\n",(0,i.jsx)(n.h2,{id:"usage-patterns",children:"Usage Patterns"}),"\n",(0,i.jsx)(n.h3,{id:"1-basic-subscription",children:"1. Basic Subscription"}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-typescript",children:"import { eventBus } from '@/canvas/eventBus';\n\n// Subscribe to pointer down events\nconst unsubscribe = eventBus.subscribe('pointerdown', (payload) => {\n  console.log('Pointer down at:', payload.point);\n  console.log('Active plugin:', payload.activePlugin);\n  console.log('Shift key pressed:', payload.event.shiftKey);\n});\n\n// Cleanup when component unmounts\nunsubscribe();\n"})}),"\n",(0,i.jsx)(n.h3,{id:"2-plugin-scoped-handler",children:"2. Plugin-Scoped Handler"}),"\n",(0,i.jsx)(n.p,{children:"Most plugins only care about events when they're active:"}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-typescript",children:"eventBus.subscribe('pointerdown', (payload) => {\n  // Early return if this plugin isn't active\n  if (payload.activePlugin !== 'my-plugin') return;\n  \n  // Handle event for this plugin\n  const { point, event } = payload;\n  startDrawing(point, event.shiftKey);\n});\n"})}),"\n",(0,i.jsx)(n.h3,{id:"3-react-hook-integration",children:"3. React Hook Integration"}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-typescript",children:"import { useEffect } from 'react';\n\nfunction MyPlugin() {\n  useEffect(() => {\n    const unsubscribe = eventBus.subscribe('pointermove', (payload) => {\n      // Handle pointer move\n    });\n    \n    // Cleanup on unmount\n    return unsubscribe;\n  }, []);\n  \n  return <div>Plugin UI</div>;\n}\n"})}),"\n",(0,i.jsx)(n.h3,{id:"4-emitting-events-less-common",children:"4. Emitting Events (Less Common)"}),"\n",(0,i.jsx)(n.p,{children:"While the canvas is the primary event emitter, plugins can emit custom events:"}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-typescript",children:"// Plugin emits a custom event\neventBus.emit('pointerdown', {\n  event: syntheticEvent,\n  point: { x: 100, y: 100 },\n  target: null,\n  activePlugin: 'my-plugin',\n  helpers,\n  state,\n});\n"})}),"\n",(0,i.jsx)(n.h2,{id:"benefits",children:"Benefits"}),"\n",(0,i.jsx)(n.h3,{id:"decoupling",children:"Decoupling"}),"\n",(0,i.jsx)(n.p,{children:"Plugins don't need to know about each other:"}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-typescript",children:"// \u274c Without Event Bus - Tight coupling\nimport { selectPlugin } from '../select';\nselectPlugin.handleClick(point);\n\n// \u2705 With Event Bus - Loose coupling\neventBus.emit('pointerdown', payload);\n"})}),"\n",(0,i.jsx)(n.h3,{id:"extensibility",children:"Extensibility"}),"\n",(0,i.jsx)(n.p,{children:"New plugins can subscribe without modifying existing code:"}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-typescript",children:"// New plugin added later\neventBus.subscribe('pointerdown', (payload) => {\n  if (payload.activePlugin === 'new-plugin') {\n    // Handle new plugin's logic\n  }\n});\n"})}),"\n",(0,i.jsx)(n.h3,{id:"testability",children:"Testability"}),"\n",(0,i.jsx)(n.p,{children:"Easy to test in isolation:"}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-typescript",children:"// Mock event bus for testing\nconst mockEventBus = {\n  subscribe: vi.fn(),\n  emit: vi.fn(),\n  clear: vi.fn(),\n};\n"})}),"\n",(0,i.jsx)(n.h3,{id:"performance",children:"Performance"}),"\n",(0,i.jsx)(n.p,{children:"Subscribers can filter events early and avoid unnecessary processing:"}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-typescript",children:"eventBus.subscribe('pointermove', (payload) => {\n  // Fast early exit for irrelevant events\n  if (payload.activePlugin !== 'pencil') return;\n  if (!isDragging) return;\n  \n  // Expensive path drawing logic only runs when needed\n  updatePath(payload.point);\n});\n"})}),"\n",(0,i.jsx)(n.h2,{id:"data-flow-example",children:"Data Flow Example"}),"\n",(0,i.jsx)(n.p,{children:"Here's how a complete pointer interaction flows through the system:"}),"\n",(0,i.jsx)(n.mermaid,{value:"graph TD\n    A[User clicks canvas] --\x3e B[Canvas onPointerDown]\n    B --\x3e C[Convert screen coords to SVG]\n    C --\x3e D[Build payload with helpers & state]\n    D --\x3e E[eventBus.emit pointerdown]\n    \n    E --\x3e F{Pencil Plugin subscribed?}\n    E --\x3e G{Select Plugin subscribed?}\n    E --\x3e H{Edit Plugin subscribed?}\n    \n    F --\x3e|Yes| F1[Check if activePlugin === 'pencil']\n    F1 --\x3e|Yes| F2[Start drawing new path]\n    F1 --\x3e|No| F3[Ignore event]\n    \n    G --\x3e|Yes| G1[Check if activePlugin === 'select']\n    G1 --\x3e|Yes| G2[Start selection rectangle]\n    G1 --\x3e|No| G3[Ignore event]\n    \n    H --\x3e|Yes| H1[Check if activePlugin === 'edit']\n    H1 --\x3e|Yes| H2[Select control point]\n    H1 --\x3e|No| H3[Ignore event]\n    \n    style E fill:#e1f5ff\n    style F2 fill:#c8e6c9\n    style G2 fill:#c8e6c9\n    style H2 fill:#c8e6c9"}),"\n",(0,i.jsx)(n.h2,{id:"implementation-location",children:"Implementation Location"}),"\n",(0,i.jsxs)(n.p,{children:[(0,i.jsx)(n.strong,{children:"File"}),": ",(0,i.jsx)(n.code,{children:"/src/canvas/eventBus.ts"})]}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-typescript",children:"export class CanvasEventBus {\n  private handlers: Map<keyof EventMap, Set<Function>> = new Map();\n\n  subscribe<K extends keyof EventMap>(\n    eventType: K,\n    handler: (payload: EventMap[K]) => void\n  ): () => void {\n    if (!this.handlers.has(eventType)) {\n      this.handlers.set(eventType, new Set());\n    }\n    this.handlers.get(eventType)!.add(handler);\n\n    // Return unsubscribe function\n    return () => {\n      this.handlers.get(eventType)?.delete(handler);\n    };\n  }\n\n  emit<K extends keyof EventMap>(eventType: K, payload: EventMap[K]): void {\n    const handlers = this.handlers.get(eventType);\n    if (handlers) {\n      handlers.forEach(handler => handler(payload));\n    }\n  }\n\n  clear(): void {\n    this.handlers.clear();\n  }\n}\n\n// Singleton instance\nexport const eventBus = new CanvasEventBus();\n"})}),"\n",(0,i.jsx)(n.h2,{id:"best-practices",children:"Best Practices"}),"\n",(0,i.jsxs)(n.ol,{children:["\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.strong,{children:"Always unsubscribe"}),": Prevent memory leaks by cleaning up subscriptions"]}),"\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.strong,{children:"Filter early"}),": Check ",(0,i.jsx)(n.code,{children:"activePlugin"})," at the start of handlers for performance"]}),"\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.strong,{children:"Avoid side effects in emitters"}),": Keep emit calls simple and predictable"]}),"\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.strong,{children:"Use typed payloads"}),": Never cast ",(0,i.jsx)(n.code,{children:"any"})," - leverage TypeScript's type safety"]}),"\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.strong,{children:"Document custom events"}),": If plugins emit events, document the payload structure"]}),"\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.strong,{children:"Test event handlers"}),": Mock the event bus to test plugin logic in isolation"]}),"\n"]}),"\n",(0,i.jsx)(n.h2,{id:"related-documentation",children:"Related Documentation"}),"\n",(0,i.jsxs)(n.ul,{children:["\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.strong,{children:(0,i.jsx)(n.a,{href:"./topics",children:"Event Topics"})}),": Complete reference for all event payload schemas"]}),"\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.strong,{children:(0,i.jsx)(n.a,{href:"./patterns",children:"Event Patterns"})}),": Advanced patterns and best practices"]}),"\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.strong,{children:(0,i.jsx)(n.a,{href:"../plugins/overview",children:"Plugin System"})}),": How plugins integrate with the Event Bus"]}),"\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.strong,{children:(0,i.jsx)(n.a,{href:"../app-structure/canvas",children:"Canvas Architecture"})}),": How the canvas emits events"]}),"\n"]})]})}function u(e={}){const{wrapper:n}={...(0,l.R)(),...e.components};return n?(0,i.jsx)(n,{...e,children:(0,i.jsx)(d,{...e})}):d(e)}}}]);